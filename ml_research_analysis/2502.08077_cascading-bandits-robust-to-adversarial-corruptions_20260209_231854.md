---
ver: rpa2
title: Cascading Bandits Robust to Adversarial Corruptions
arxiv_id: '2502.08077'
source_url: https://arxiv.org/abs/2502.08077
tags:
- uni00000026
- uni00000044
- bandits
- uni00000048
- item
- transformers
- self-attention
- retrieval-augmented-generation
- instruction-tuning
- parameter-efficient-finetuning
- mixture-of-experts
- chain-of-thought
core_contribution: This paper studies the Cascading Bandits with Adversarial Corruptions
  (CBAC) problem, where an adaptive adversary can manipulate user feedback in online
  learning to rank systems. The authors propose two robust algorithms, CascadeRKC
  and CascadeRAC, designed to handle known and agnostic corruption levels, respectively.
---

# Cascading Bandits Robust to Adversarial Corruptions

## Quick Facts
- arXiv ID: 2502.08077
- Source URL: https://arxiv.org/abs/2502.08077
- Authors: Jize Xie; Cheng Chen; Zhiyong Wang; Shuai Li
- Reference count: 16
- Key outcome: Novel robust algorithms (CascadeRKC and CascadeRAC) achieve logarithmic regret when not under attack, with regret increasing linearly with corruption level

## Executive Summary
This paper addresses the Cascading Bandits with Adversarial Corruptions (CBAC) problem, where an adaptive adversary can manipulate user feedback in online learning to rank systems. The authors propose two robust algorithms, CascadeRKC and CascadeRAC, designed to handle known and agnostic corruption levels respectively. These algorithms employ a novel position-based elimination method that maintains separate elimination sets for each position in the recommended list, enabling more efficient identification of optimal items. The theoretical analysis demonstrates tighter regret bounds compared to existing methods, with experimental validation on synthetic and real-world datasets confirming the algorithms' robustness under various corruption mechanisms and levels.

## Method Summary
The authors introduce a position-based elimination approach where each position in the recommendation list maintains its own elimination set. CascadeRKC leverages knowledge of the corruption level by maintaining two instances with different confidence radii, allowing it to switch between exploration and robust modes. CascadeRAC maintains multiple instances to handle agnostic corruption, continuously monitoring for adversarial attacks. Both algorithms achieve logarithmic regret in clean environments while gracefully degrading under corruption, with regret scaling linearly with the corruption level.

## Key Results
- CascadeRKC and CascadeRAC achieve tighter regret bounds than existing methods in CBAC setting
- Both algorithms maintain logarithmic regret when not under attack
- Regret increases linearly with corruption level, demonstrating graceful degradation
- Experimental results confirm robustness across various corruption mechanisms on synthetic and real-world datasets

## Why This Works (Mechanism)
The position-based elimination method works by maintaining separate candidate sets for each position, allowing the algorithm to identify optimal items more efficiently than traditional elimination methods. By tracking corruption-specific metrics and adjusting confidence radii based on the observed corruption level, the algorithms can distinguish between genuine user feedback and adversarial manipulation. The dual-instance approach in CascadeRKC enables adaptive switching between exploration and robust modes, while CascadeRAC's multi-instance design provides flexibility in handling unknown corruption levels.

## Foundational Learning
- **Cascading Bandits**: Multi-armed bandit problem where items are presented in a ranked list and user engagement follows a cascade model. Needed to understand the problem setting; quick check: user stops examining items after first failure.
- **Adversarial Corruptions**: Model where an adaptive adversary can manipulate feedback to degrade algorithm performance. Needed to frame the robust learning challenge; quick check: corruption level κ bounds total adversarial manipulations.
- **Confidence Radius**: Statistical measure determining when to eliminate suboptimal arms. Needed for the elimination mechanism; quick check: radius scales with exploration parameter and observed rewards.
- **Position-based Elimination**: Method maintaining separate elimination sets for each position in recommendation list. Needed for efficient item identification; quick check: each position has independent candidate pool.
- **Regret Analysis**: Framework for measuring cumulative performance loss relative to optimal policy. Needed to quantify algorithm effectiveness; quick check: regret bounds scale with T (time horizon) and κ (corruption level).

## Architecture Onboarding

**Component Map:**
User Feedback -> Corruption Detection -> Position-based Elimination -> Arm Selection -> Recommendation List

**Critical Path:**
1. Observe user feedback and rewards
2. Detect potential adversarial corruption
3. Update position-specific elimination sets
4. Select arms for next round based on remaining candidates
5. Present ranked recommendation list

**Design Tradeoffs:**
- Computational complexity vs. robustness: Multiple instances increase robustness but require more computation
- Exploration vs. exploitation: Confidence radii must balance between discovering optimal arms and avoiding corrupted feedback
- Position independence vs. global optimization: Separate elimination sets improve efficiency but may miss global patterns

**Failure Signatures:**
- Linear regret growth indicates high corruption levels exceeding algorithm's tolerance
- Slow elimination suggests confidence radii too conservative
- Premature eliminations indicate radii too aggressive

**First 3 Experiments:**
1. Test algorithm performance on synthetic data with controlled corruption levels (κ = 0, κ = 0.1T, κ = 0.5T)
2. Compare regret bounds of CascadeRKC vs. CascadeRAC under known vs. unknown corruption scenarios
3. Evaluate robustness to different corruption mechanisms (random vs. targeted manipulations)

## Open Questions the Paper Calls Out
None

## Limitations
- Position-based elimination requires careful calibration of confidence radii parameters
- Performance degrades linearly with corruption levels, indicating vulnerability in highly adversarial environments
- Experimental validation limited to synthetic data and single real-world dataset, constraining generalizability

## Confidence
- **High Confidence**: Theoretical regret bounds for CascadeRKC and CascadeRAC under known/agnostic corruption models
- **Medium Confidence**: Experimental superiority claims over existing methods, given limited dataset diversity
- **Medium Confidence**: Position-based elimination mechanism effectiveness, pending broader empirical validation

## Next Checks
1. Test algorithm performance across diverse real-world datasets with varying user behavior patterns to assess robustness beyond the current validation scope
2. Evaluate computational efficiency and scalability when extending to large item catalogs and multiple user segments
3. Conduct ablation studies to quantify the impact of different confidence radius configurations on algorithm performance