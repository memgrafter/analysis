---
ver: rpa2
title: Goal-Driven Query Answering over First- and Second-Order Dependencies with
  Equality
arxiv_id: '2412.09125'
source_url: https://arxiv.org/abs/2412.09125
tags:
- each
- rule
- dependencies
- function
- query
- transformers
- self-attention
- retrieval-augmented-generation
- instruction-tuning
- parameter-efficient-finetuning
- mixture-of-experts
- chain-of-thought
core_contribution: This paper presents the first goal-driven query answering approach
  for first- and second-order dependencies with equality reasoning. The method transforms
  input dependencies through a multi-step pipeline that includes singularisation,
  relevance analysis, and a modified magic sets transformation, enabling efficient
  backward chaining without computing the full universal model.
---

# Goal-Driven Query Answering over First- and Second-Order Dependencies with Equality

## Quick Facts
- arXiv ID: 2412.09125
- Source URL: https://arxiv.org/abs/2412.09125
- Authors: Efthymia Tsamoura; Boris Motik
- Reference count: 40
- Primary result: First goal-driven query answering approach for first- and second-order dependencies with equality reasoning

## Executive Summary
This paper presents a novel goal-driven approach for answering queries over first- and second-order dependencies with equality reasoning. The method transforms input dependencies through a multi-step pipeline including singularisation, relevance analysis, and a modified magic sets transformation, enabling efficient backward chaining without computing the full universal model. The approach addresses the computational inefficiency of full chase-based query answering when only a subset of inferences is relevant to a given query. Empirical evaluation shows that goal-driven query answering can be orders of magnitude faster than computing the full universal model, with relevance analysis being the primary driver of performance improvements.

## Method Summary
The method transforms input second-order dependencies through a 7-step pipeline: fol (eliminate second-order quantifiers) → singularisation → skolemisation → relevance analysis → magic sets → defun (remove function symbols from bodies) → desingularisation. The final program is evaluated using a chase variant that treats ≈ as true equality. Singularisation converts second-order dependencies to first-order by dropping quantifiers and treating function variables as function symbols with D-restricted functional reflexivity axioms. Relevance analysis identifies and eliminates dependency rules that provably cannot contribute to query answers. Magic sets transformation prunes irrelevant rule instances by simulating top-down query evaluation. The approach is correct and complete for query answering while avoiding the computational cost of computing the full universal model.

## Key Results
- Goal-driven query answering can be orders of magnitude faster than computing the full universal model
- Relevance analysis is the primary driver of performance improvements
- The method significantly reduces the number of derived facts in practice
- Approach correctly handles both first- and second-order dependencies with equality reasoning

## Why This Works (Mechanism)

### Mechanism 1
- Claim: Singularisation transforms second-order dependencies into first-order dependencies without losing query answers by carefully restricting functional reflexivity.
- Mechanism: The algorithm removes congruence axioms (13) and replaces them with D-restricted functional reflexivity axioms (22). This limits equality derivations to domain elements appearing in relational predicates, avoiding infinite chains like f^n(a) ≈ f^m(a).
- Core assumption: The relevant domain for equality derivations can be bounded by the subset of terms appearing in relational facts, and safety ensures no needed equalities are lost.
- Evidence anchors:
  - [abstract] "corrects an incompleteness of a related formulation by ten Cate et al. [74]"
  - [section 4.2] "Theorem 7 states that, regardless of how singularisation steps are applied, the result preserves query answers despite the fact that functional reflexivity dependencies are D-restricted"

### Mechanism 2
- Claim: Relevance analysis identifies and eliminates entire dependency rules that provably cannot contribute to query answers, significantly reducing the chase space.
- Mechanism: The algorithm constructs an abstraction of the base instance, computes its consequences under the program, then performs backward chaining from query answers to identify relevant rules. Rules not identified as relevant are removed.
- Core assumption: The abstraction preserves homomorphism of query answers, so irrelevant rules in the abstraction are irrelevant in the full instance.
- Evidence anchors:
  - [abstract] "presents a relevance analysis technique that can eliminate from the input dependencies that provably do not contribute to query answers"
  - [section 4.4] "Theorem 15 states that relevant rules are sufficient to correctly derive all query answers"

### Mechanism 3
- Claim: Magic sets transformation prunes irrelevant rule instances by simulating top-down query evaluation, reducing the number of facts derived during chase.
- Mechanism: The algorithm introduces magic predicates that accumulate bindings relevant to the query, then modifies rules to be guarded by these predicates. This simulates sideways information passing from top-down evaluation.
- Core assumption: The magic predicate propagation correctly identifies all and only the relevant rule instances for the query, without introducing incompleteness.
- Evidence anchors:
  - [abstract] "presents a variant of the magic sets algorithm [19] that can handle second-order dependencies with equality reasoning"
  - [section 4.5] "Theorem 21 shows that the query answers nevertheless remain preserved"

## Foundational Learning

- Concept: Second-order logic with function variables vs first-order logic with function symbols
  - Why needed here: The paper's approach converts second-order dependencies to first-order by dropping second-order quantifiers and treating function variables as function symbols, which changes the semantics but preserves query answers
  - Quick check question: Why can we replace existentially quantified function variables with function symbols when answering queries, but not when describing transformations between schemas?

- Concept: Equality axiomatization strategies (explicit vs singularisation)
  - Why needed here: The paper compares explicit axiomatization of equality (with congruence axioms) versus singularisation (without congruence axioms but with modified dependency bodies), showing singularisation avoids inefficiency
  - Quick check question: What is the key inefficiency of explicit equality axiomatization that singularisation addresses, and how does singularisation compensate for removing congruence axioms?

- Concept: Chase termination conditions and their relationship to dependency properties
  - Why needed here: The paper's approach depends on the chase terminating, and references various acyclicity conditions that guarantee termination for different dependency classes
  - Quick check question: Why does adding unrestricted functional reflexivity axioms prevent chase termination, while D-restricted versions may allow it to terminate?

## Architecture Onboarding

- Component map: fol → singularisation → skolemisation → relevance analysis → magic sets → defun → desingularisation
- Critical path: fol → singularisation → skolemisation → relevance analysis → magic sets → defun → desingularisation → chase evaluation
- Design tradeoffs: Singularisation vs explicit equality axiomatization trades potential completeness for efficiency; relevance analysis vs magic sets trades fixed overhead for instance-level pruning; keeping function symbols vs eliminating them trades expressiveness for evaluation efficiency
- Failure signatures: Infinite chase loops (unrestricted functional reflexivity); incomplete query answers (incorrect relevance analysis or magic sets); performance degradation (large intermediate programs); memory exhaustion (too many derived facts)
- First 3 experiments:
  1. Run on LUBM-100 with just relevance analysis vs full chase to measure overhead vs pruning benefit
  2. Run on Gen-26-1k with just magic sets vs full chase to measure magic predicate overhead vs instance pruning
  3. Run on Ont-256 with both techniques vs full chase to measure combined effect on equality-heavy scenarios

## Open Questions the Paper Calls Out

### Open Question 1
- Question: What are the theoretical limits of goal-driven query answering in second-order dependencies when the chase does not terminate? Can relevance analysis and magic sets still provide meaningful performance improvements?
- Basis in paper: [inferred] The paper mentions that the chase does not terminate in general for second-order dependencies and that relevance analysis and magic sets are complementary techniques, but does not explore the implications of non-termination on goal-driven query answering.
- Why unresolved: The paper focuses on scenarios where the chase terminates, but does not investigate the performance of goal-driven techniques in cases of non-termination.
- What evidence would resolve it: Empirical results comparing goal-driven query answering techniques on second-order dependencies with known non-termination properties, showing whether relevance analysis and magic sets still provide performance improvements.

### Open Question 2
- Question: Can the techniques presented in the paper be extended to handle guarded second-order dependencies or other decidable classes of second-order dependencies?
- Basis in paper: [inferred] The paper mentions that it is unclear how to perform backward chaining over finite representations of infinite models for guarded dependencies, and that ensuring the magic sets transformation result falls into a decidable dependency class is a challenge.
- Why unresolved: The paper does not explore the application of the techniques to guarded second-order dependencies or other decidable classes of second-order dependencies.
- What evidence would resolve it: Theoretical analysis and/or empirical results demonstrating the applicability of the techniques to guarded second-order dependencies or other decidable classes of second-order dependencies.

### Open Question 3
- Question: What is the optimal strategy for combining relevance analysis and magic sets in goal-driven query answering over second-order dependencies?
- Basis in paper: [explicit] The paper mentions that the combination of both techniques often produces the best results, but does not provide a detailed analysis of the optimal strategy for combining them.
- Why unresolved: The paper does not provide a systematic study of the trade-offs between relevance analysis and magic sets, or guidelines for determining when to use each technique or both in combination.
- What evidence would resolve it: Empirical results comparing different strategies for combining relevance analysis and magic sets, showing the impact on query answering performance for various types of second-order dependencies and queries.

## Limitations

- The approach assumes finite or effectively bounded domains for relevance analysis, with unclear behavior for infinite domains
- The interaction between relevance analysis (which eliminates entire rules) and magic sets (which prunes rule instances) could potentially lead to missed query answers
- The paper does not explore the performance of goal-driven techniques in cases where the chase does not terminate

## Confidence

- Goal-driven approach correctness: High - Theorem 7 and related proofs provide strong theoretical foundation
- Relevance analysis effectiveness: Medium - empirical results show significant pruning, but worst-case complexity guarantees are limited
- Magic sets preservation of answers: High - Theorem 21 provides formal proof of answer preservation
- Overall performance improvements: Medium - empirical results show orders of magnitude improvements, but benchmarks may favor the technique

## Next Checks

1. Test on LUBM-10k with only relevance analysis enabled to verify overhead is minimal and pruning is effective in large-scale scenarios
2. Verify on Gen-26-1k that magic sets transformation correctly handles equality by comparing answers with and without magic sets on equality-heavy queries
3. Run Ont-256 with both relevance analysis and magic sets disabled to establish baseline chase performance for comparison