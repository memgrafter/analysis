---
ver: rpa2
title: Automated Conversion of Static to Dynamic Scheduler via Natural Language
arxiv_id: '2405.06697'
source_url: https://arxiv.org/abs/2405.06697
tags:
- constraint
- each
- range
- assigned
- worker
- transformers
- self-attention
- retrieval-augmented-generation
- instruction-tuning
- parameter-efficient-finetuning
- mixture-of-experts
- chain-of-thought
core_contribution: This paper presents RAGDYS, a framework that automatically converts
  static scheduling models to dynamic ones using natural language descriptions of
  constraints. The method employs a Retrieval-Augmented Generation (RAG) approach
  with planning and coding agents to modify existing scheduling code when disturbances
  occur.
---

# Automated Conversion of Static to Dynamic Scheduler via Natural Language

## Quick Facts
- **arXiv ID:** 2405.06697
- **Source URL:** https://arxiv.org/abs/2405.06697
- **Reference count:** 40
- **Key outcome:** RAGDYS framework achieves 90% success rate in automatically generating dynamic scheduling constraints from natural language descriptions

## Executive Summary
This paper presents RAGDYS, a framework that automatically converts static scheduling models to dynamic ones using natural language descriptions of constraints. The method employs a Retrieval-Augmented Generation (RAG) approach with planning and coding agents to modify existing scheduling code when disturbances occur. Using OpenAI GPT-4 as the coding agent, the framework achieved a 90% success rate in automatically generating correct constraints for both seen (Gig-Scheduling Problem) and unseen (Nurse Scheduling Problem) scheduling problems. The framework effectively handles dynamic constraint addition while maintaining schedule stability through minimum perturbation constraints, enabling non-technical end-users to update optimization models without expert intervention.

## Method Summary
RAGDYS uses a RAG architecture with planning and coding agents to automatically convert static scheduling models to dynamic ones based on natural language descriptions. The framework retrieves relevant examples from a vector database, generates new parameters and constraints through the planning agent, and modifies existing code via the coding agent. Minimum perturbation constraints ensure schedule stability by limiting changes to the original schedule. The system achieves 90% success rate in constraint generation for both seen and unseen scheduling problems using OpenAI GPT-4.

## Key Results
- 90% success rate in automatically generating correct constraints for seen and unseen scheduling problems
- Framework successfully generalizes to different scheduling problem structures (Gig-Scheduling and Nurse Scheduling)
- Minimum perturbation constraints maintain schedule stability while incorporating new constraints

## Why This Works (Mechanism)

### Mechanism 1
- Claim: The framework can generalize dynamic constraint generation to unseen scheduling problems by leveraging existing problem formulations and code as context.
- Mechanism: RAGDYS uses existing static scheduling problem descriptions, formulations, and code as context for the LLM planning and coding agents. When a new dynamic constraint is described in natural language, the agents retrieve similar examples from the vector database and use them to generate new parameters, variables, and constraints that fit the existing problem structure.
- Core assumption: The LLM can effectively understand the structure of the existing scheduling problem and correctly map the new constraint to appropriate modifications in the mathematical formulation and code.
- Evidence anchors:
  - [abstract]: "Using OpenAI GPT-4 as the coding agent, the framework achieved a 90% success rate in automatically generating correct constraints for both seen (Gig-Scheduling Problem) and unseen (Nurse Scheduling Problem) scheduling problems."
  - [section 4.3]: "In general, automatic evaluation has shown that for both seen and unseen constraints for the same and different base problems, the model attains a 90% match rate."
- Break condition: The LLM fails to correctly map the natural language constraint to the existing problem structure, leading to incorrect or missing constraints in the generated code.

### Mechanism 2
- Claim: The framework maintains schedule stability by incorporating minimum perturbation constraints that limit the deviation from the original schedule.
- Mechanism: When adding a dynamic constraint, the framework also adds a minimum perturbation constraint that limits the Hamming distance between the new schedule and the original schedule. This ensures that the new schedule doesn't deviate too much from the original, maintaining stability for end-users.
- Core assumption: The minimum perturbation constraint can be effectively formulated and added to the existing optimization problem without causing infeasibility or excessive computational burden.
- Evidence anchors:
  - [section 1.1]: "The planner wants to ensure that the repaired schedule is within T number of changes to X. We term T as the perturbation threshold."
  - [section 2.2]: "Our proposed method will allow the planner to generate a revised model and the corresponding code to reflect these constraints, via a natural language description of the disturbance and perturbation."
- Break condition: The minimum perturbation constraint makes the problem infeasible or significantly increases computational complexity, preventing practical solution within acceptable timeframes.

### Mechanism 3
- Claim: The framework reduces technical complexity for end-users by automating the mathematical modeling and code generation process through natural language interaction.
- Mechanism: Non-technical end-users can describe dynamic constraints in simple natural language, and the framework automatically generates the corresponding mathematical formulations and code modifications. This eliminates the need for users to understand complex optimization modeling concepts or programming.
- Core assumption: Natural language descriptions provided by end-users can be reliably parsed and translated into appropriate mathematical constraints by the LLM agents.
- Evidence anchors:
  - [abstract]: "Our framework aims to minimize technical complexities related to mathematical modelling and computational workload for end-users, thereby allowing end-users to quickly obtain a new schedule close to the original schedule with changes reflected by natural language constraint descriptions."
  - [section 1.2]: "Our framework aims to minimize technical complexities related to mathematical modelling and computational workload for end-users."
- Break condition: The natural language descriptions are too ambiguous or use terminology unfamiliar to the LLM, leading to misinterpretation and incorrect constraint generation.

## Foundational Learning

- Concept: Constraint Programming and Optimization
  - Why needed here: The framework relies on constraint programming formulations to represent scheduling problems and their constraints. Understanding how to model scheduling problems using constraints is essential for interpreting the framework's operation and results.
  - Quick check question: What is the difference between a constraint satisfaction problem (CSP) and a constraint optimization problem (COP) in the context of scheduling?

- Concept: Retrieval-Augmented Generation (RAG)
  - Why needed here: RAG is the core technique used to provide context-specific knowledge to the LLM agents. Understanding how RAG works and its applications is crucial for grasping how the framework generalizes to new problems.
  - Quick check question: How does RAG differ from traditional fine-tuning approaches when adapting a pre-trained model to a new domain?

- Concept: Minimum Perturbation Problems
  - Why needed here: The framework specifically addresses minimum perturbation problems, which involve modifying existing schedules with minimal changes while incorporating new constraints. Understanding the concept of perturbation distance and its role in dynamic scheduling is important for evaluating the framework's effectiveness.
  - Quick check question: What are the advantages and disadvantages of formulating minimum perturbation as a hard constraint versus an objective function to be minimized?

## Architecture Onboarding

- Component map: Vector Database -> Planning Agent -> Coding Agent -> Code Execution Engine -> End-User Interface
- Critical path: Natural language description → Vector Database retrieval → Planning Agent output → Coding Agent output → Code execution → New schedule
- Design tradeoffs:
  - Using RAG vs. fine-tuning: RAG avoids the computational cost and potential degradation of model performance associated with fine-tuning, but may be less effective for highly specialized domains
  - Minimum perturbation as hard constraint vs. soft constraint: Hard constraints ensure schedule stability but may cause infeasibility, while soft constraints allow flexibility but may result in larger perturbations
  - Single LLM vs. separate planning and coding agents: Separate agents allow specialization but increase complexity and potential for communication errors
- Failure signatures:
  - High rate of code errors (KeyError, SyntaxError) indicating the coding agent is misinterpreting the planning agent output or retrieved examples
  - Infeasible solutions suggesting the minimum perturbation constraint is too restrictive or conflicts with new constraints
  - False positives in automatic evaluation indicating the generated code produces correct schedules for the wrong reasons
  - Hallucinated parameters in the generated code showing the LLM is inventing parameters not present in the original problem
- First 3 experiments:
  1. Run the framework with a simple dynamic constraint on the Gig-Scheduling Problem (e.g., "Worker A cannot work from hour 5 to hour 10") and verify the generated code correctly implements this constraint.
  2. Test the framework's ability to generalize by applying the same constraint type to the Nurse Scheduling Problem and checking if the generated code correctly maps the constraint to the nurse-day-shift structure.
  3. Evaluate the minimum perturbation functionality by introducing a constraint that requires significant schedule changes and measuring the actual Hamming distance between the original and new schedules.

## Open Questions the Paper Calls Out

### Open Question 1
- Question: How does the RAGDYS framework perform on scheduling problems with constraints that require more complex logical reasoning, such as conditional constraints or constraints with interdependent parameters?
- Basis in paper: [inferred] The paper focuses on relatively straightforward constraint additions and does not explore the framework's performance on more complex constraint types that might require advanced logical reasoning.
- Why unresolved: The evaluation primarily tests simple constraint additions and does not include scenarios with complex logical dependencies or conditional constraints that might challenge the framework's reasoning capabilities.
- What evidence would resolve it: Testing the framework on scheduling problems with complex constraints like "if condition A is met, then constraint B applies" or constraints that depend on multiple interrelated parameters, and measuring success rates and accuracy of generated constraints.

### Open Question 2
- Question: What is the impact of the maximum perturbation threshold (T) on solution quality and computational efficiency, and how should T be optimally set for different scheduling scenarios?
- Basis in paper: [explicit] The paper mentions the minimum perturbation constraint and its purpose but does not explore how different values of T affect solution quality or computational performance.
- Why unresolved: The paper uses a fixed T value in experiments but does not investigate how varying this parameter influences the trade-off between solution stability and optimality.
- What evidence would resolve it: Systematic experiments varying T values across different scheduling scenarios to measure impacts on solution quality, computational time, and constraint satisfaction rates.

### Open Question 3
- Question: How does the framework handle scheduling problems with large numbers of nurses, shifts, and days, and what are its scalability limitations?
- Basis in paper: [inferred] While the paper demonstrates functionality on moderate-sized scheduling problems, it does not address scalability challenges that might arise with larger, real-world instances.
- Why unresolved: The evaluation uses relatively small problem instances and does not explore performance degradation or memory constraints when scaling to industrial-sized scheduling problems.
- What evidence would resolve it: Testing the framework on progressively larger scheduling instances to identify computational bottlenecks, memory constraints, and performance degradation patterns.

## Limitations
- The 90% success rate is measured through syntactic matching rather than semantic validation of schedule quality
- Framework performance on highly complex constraints with intricate interdependencies remains unclear
- Computational overhead of RAG process and code execution engine is not quantified for time-sensitive applications

## Confidence
- **High confidence:** The core RAGDYS framework architecture and its ability to generate code for seen problems
- **Medium confidence:** Generalization to unseen scheduling problems (Nurse Scheduling Problem) and the effectiveness of minimum perturbation constraints
- **Low confidence:** The semantic correctness of generated schedules and the framework's performance under complex, interdependent constraints

## Next Checks
1. Conduct a human-in-the-loop evaluation where domain experts verify whether schedules generated for dynamic constraints actually satisfy the intended requirements and maintain feasibility
2. Test the framework with progressively more complex constraints that have intricate dependencies on existing constraints to identify breaking points in generalization capability
3. Measure end-to-end computational time including RAG retrieval, planning, coding, and execution phases to quantify practical applicability for real-time scheduling adjustments