---
ver: rpa2
title: Introduction to AI Planning
arxiv_id: '2412.11642'
source_url: https://arxiv.org/abs/2412.11642
tags:
- planning
- state
- task
- problem
- variables
- transformers
- self-attention
- retrieval-augmented-generation
- instruction-tuning
- parameter-efficient-finetuning
- mixture-of-experts
- chain-of-thought
core_contribution: This paper provides lecture notes introducing key concepts and
  techniques in AI Planning. It covers classical planning, constraint satisfaction
  problem (CSP) planning, and Hierarchical Task Network (HTN) planning.
---

# Introduction to AI Planning

## Quick Facts
- arXiv ID: 2412.11642
- Source URL: https://arxiv.org/abs/2412.11642
- Authors: Marco Aiello; Ilche Georgievski
- Reference count: 32
- Primary result: Comprehensive lecture notes introducing classical planning, CSP planning, and HTN planning with algorithms and complexity analysis

## Executive Summary
This paper presents lecture notes introducing fundamental concepts and techniques in AI Planning. The notes cover classical planning, constraint satisfaction problem (CSP) planning, and Hierarchical Task Network (HTN) planning, providing both theoretical foundations and practical algorithms. A significant focus is given to HTN planning, including task decomposition, search spaces, constraints, and task interactions. The notes conclude with a bonus chapter on the Planning Domain Definition Language (PDDL) as a standard representation language for planning problems.

## Method Summary
The paper introduces AI planning concepts through a structured progression from state models to classical planning, then to CSP planning, and finally to HTN planning. It presents fundamental algorithms including forward and backward search for classical planning, CSP encoding approaches, and HTN decomposition techniques. The methodology emphasizes understanding computational complexity alongside algorithmic solutions, providing a balanced theoretical and practical perspective on planning approaches.

## Key Results
- Introduces foundational state models and classical planning algorithms with complexity analysis
- Presents CSP encoding methods for planning problems and their algorithmic solutions
- Provides comprehensive coverage of HTN planning concepts including task decomposition and constraint handling
- Includes PDDL as a standard representation language for planning problems

## Why This Works (Mechanism)

### Mechanism 1
- **Claim:** The lecture notes structure supports learning by presenting concepts in increasing complexity, starting with state models, moving to classical planning, then CSP planning, and finally HTN planning.
- **Mechanism:** The incremental progression from simple deterministic state models to more complex hierarchical task networks allows learners to build foundational understanding before tackling advanced concepts.
- **Core assumption:** Learners can grasp new planning concepts effectively when they have a solid understanding of simpler planning paradigms first.
- **Evidence anchors:**
  - [abstract] "The notes begin by introducing the state model and move on to exploring classical planning"
  - [section] "The notes begin by introducing the state model and move on to exploring classical planning, the foundational form of planning"
- **Break condition:** If learners lack the mathematical or logical background to understand state transition systems, the progression will fail.

### Mechanism 2
- **Claim:** The integration of complexity analysis throughout the notes helps learners understand the practical limitations and tradeoffs of different planning approaches.
- **Mechanism:** By presenting complexity results (PSPACE-complete for classical planning, NP-complete for certain HTN variants) alongside algorithmic solutions, learners gain realistic expectations about what's computationally feasible.
- **Core assumption:** Understanding computational complexity is essential for selecting appropriate planning techniques in real-world applications.
- **Evidence anchors:**
  - [abstract] "The notes present fundamental algorithms for solving such problems" and "discuss the complexity of different planning approaches"
  - [section] "The worst-case complexity is a common way to get a general understanding of the feasibility and difficulty of solving a computational problem"
- **Break condition:** If learners skip the complexity sections, they may develop unrealistic expectations about planning capabilities.

### Mechanism 3
- **Claim:** The inclusion of PDDL as a bonus chapter provides practical value by introducing the standard representation language for planning problems.
- **Mechanism:** PDDL bridges theoretical concepts with practical implementation, allowing learners to translate abstract planning problems into a formal language that can be executed by planners.
- **Core assumption:** Learners benefit from understanding both the theoretical foundations and practical representation of planning problems.
- **Evidence anchors:**
  - [abstract] "The lecture notes end with a bonus chapter on the Planning Domain Definition (PDDL) Language"
  - [section] "A standard representation for describing problems in planning is the Planning Domain Definition Language (PDDL)"
- **Break condition:** If learners don't have programming experience, the PDDL chapter may be less accessible.

## Foundational Learning

- **Concept:** State transition systems
  - **Why needed here:** The state model is the foundation upon which all planning approaches in the notes are built.
  - **Quick check question:** What are the five components of a state model M = ⟨S, s0, SG, A, δ⟩?

- **Concept:** First-order logic and predicate representation
  - **Why needed here:** PDDL and HTN planning both rely on first-order representations with predicates, variables, and logical connectives.
  - **Quick check question:** How does a ground atom differ from a parametrized predicate in PDDL?

- **Concept:** Computational complexity classes (PSPACE, NP, P)
  - **Why needed here:** The notes discuss complexity results for different planning problems, requiring understanding of what these complexity classes mean.
  - **Quick check question:** What does it mean for a problem to be PSPACE-complete, and why is this significant for planning?

## Architecture Onboarding

- **Component map:** Domain parser -> State space builder -> Search algorithm selector -> Constraint solver -> Plan generator
- **Critical path:**
  1. Parse domain and problem descriptions (PDDL or HTN format)
  2. Build internal representation (state space, task networks)
  3. Select appropriate planning algorithm based on problem characteristics
  4. Execute search with constraint propagation/backtracking
  5. Return plan or indicate unsolvability

- **Design tradeoffs:**
  - Breadth vs. depth in search: Affects memory usage and solution quality
  - Forward vs. backward search: Forward search has better heuristics but explores irrelevant actions
  - Least-commitment vs. early-commitment: Impacts search space size and plan quality
  - Complete vs. incomplete algorithms: Guarantees solution existence vs. practical performance

- **Failure signatures:**
  - Memory exhaustion: Indicates need for better heuristics or incomplete algorithms
  - Extremely long computation times: Suggests problem complexity exceeds practical limits
  - Inconsistent constraint propagation: Points to domain representation issues
  - No applicable actions found: May indicate unreachable goals or incorrect domain specification

- **First 3 experiments:**
  1. Implement forward search on a simple PDDL problem (e.g., blocks world) and measure performance
  2. Add constraint propagation to the forward search and compare search space reduction
  3. Implement HTN task decomposition on a hierarchical domain and evaluate solution quality vs. classical planning

## Open Questions the Paper Calls Out

### Open Question 1
- Question: What are the practical implications of the complexity differences between totally ordered, partially ordered, and unordered HTN planning approaches in real-world applications?
- Basis in paper: [explicit] The paper discusses TOTD, UTD, and POTD task decomposition styles and their complexity results in Table 1.
- Why