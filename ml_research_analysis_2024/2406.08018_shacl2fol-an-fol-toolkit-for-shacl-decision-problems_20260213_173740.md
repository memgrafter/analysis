---
ver: rpa2
title: 'SHACL2FOL: An FOL Toolkit for SHACL Decision Problems'
arxiv_id: '2406.08018'
source_url: https://arxiv.org/abs/2406.08018
tags:
- shacl
- graph
- shape
- satis
- constraints
- transformers
- self-attention
- retrieval-augmented-generation
- instruction-tuning
- parameter-efficient-finetuning
- mixture-of-experts
- chain-of-thought
core_contribution: SHACL2FOL is the first tool that translates SHACL constraints into
  first-order logic and solves the key decision problems of satisfiability and containment
  for SHACL shape graphs. It generates TPTP-formatted first-order theories for shape
  graphs, data graphs, and validation problems, enabling integration with standard
  theorem provers like E and Vampire.
---

# SHACL2FOL: An FOL Toolkit for SHACL Decision Problems

## Quick Facts
- **arXiv ID:** 2406.08018
- **Source URL:** https://arxiv.org/abs/2406.08018
- **Reference count:** 14
- **Primary result:** First tool translating SHACL to FOL for solving satisfiability and containment decision problems

## Executive Summary
SHACL2FOL is the first tool that translates SHACL constraints into first-order logic and solves the key decision problems of satisfiability and containment for SHACL shape graphs. It generates TPTP-formatted first-order theories for shape graphs, data graphs, and validation problems, enabling integration with standard theorem provers like E and Vampire. The tool addresses theoretical SHACL validation, containment, and satisfiability by reducing them to first-order logic reasoning. Preliminary testing shows it handles small shape graphs effectively, supporting static analysis tasks like constraint validation and optimization.

## Method Summary
SHACL2FOL translates SHACL documents into First-Order Logic (FOL) sentences and computes satisfiability and containment problems. The tool takes SHACL shape graphs and data graphs as inputs, generating serializations of first-order sentences that are satisfiable if and only if the data graph conforms to the shape graph. It outputs TPTP-formatted theories compatible with theorem provers, handling both validation and containment checking. The implementation includes two approaches for encoding the Unique Name Assumption: pairwise inequality axioms and TPTP's "$distinct" type for better scalability.

## Key Results
- First implementation translating SHACL to FOL for satisfiability and containment problems
- Successfully generates TPTP-formatted theories from SHACL shape graphs and data graphs
- Preliminary testing shows effective handling of small shape graphs for static analysis tasks
- Demonstrates SHACL validation can be represented as first-order logic satisfiability problems

## Why This Works (Mechanism)

### Mechanism 1
- Claim: SHACL2FOL enables formal verification of SHACL shape graphs by translating them into First-Order Logic (FOL) and leveraging existing theorem provers.
- Mechanism: The tool translates SHACL shapes into SCL (SHACL First-Order Language) sentences, which are then serialized into TPTP format for compatibility with theorem provers like E and Vampire. This translation preserves the semantics of SHACL constraints, allowing formal reasoning about satisfiability, containment, and validation.
- Core assumption: The translation from SHACL to SCL is semantically accurate and complete for the SHACL core constraint components.
- Evidence anchors:
  - [abstract] "translates SHACL documents into FOL sentences and computes the answer to the two static analysis problems of satisfiability and containment"
  - [section] "SHACL2FOL takes a shape graph A and a data graph G as inputs, and generates a serialisation of a first order sentence that is satisfiable if and only if the data graph conforms to the shape graph"
- Break condition: If the translation misses or incorrectly models any SHACL constraint component, the formal verification results will be incorrect or incomplete.

### Mechanism 2
- Claim: SHACL2FOL provides scalable static analysis by offering two approaches to handle the Unique Name Assumption (UNA).
- Mechanism: The tool implements UNA using either pairwise inequality axioms (polynomial growth) or TPTP's "$distinct" type (linear growth). The second approach scales better with large data graphs by declaring constants as distinct rather than generating all pairwise inequalities.
- Core assumption: The "$distinct" type in TPTP provides a valid alternative to explicit pairwise inequality axioms for enforcing UNA.
- Evidence anchors:
  - [section] "In the first approach, UNA is encoded as the pairwise inequality of all known constants... The second approach makes use of the '$distinct' type of Typed First-Order Form with Arithmetic (TFF)"
- Break condition: If theorem provers do not properly handle the "$distinct" type, or if the type introduces inconsistencies, the scalability benefit may not materialize.

### Mechanism 3
- Claim: SHACL2FOL enables validation checking by combining shape graph translation with data graph serialization.
- Mechanism: For validation, SHACL2FOL generates a FOL sentence that is the conjunction of τ(A) (shape graph translation) and τ+(G) ∧ τ-(G) (data graph serialization). This ensures that the interpretation of binary relations in the theorem prover matches the actual triples in the data graph.
- Core assumption: The serialization τ+(G) ∧ τ-(G) correctly captures the exact set of triples in the data graph without introducing false positives or negatives.
- Evidence anchors:
  - [section] "When performing validation, SHACL2FOL takes a shape graph A and a data graph G as inputs, and generates a serialisation of a first order sentence that is satisfiable if and only if the data graph conforms to the shape graph"
- Break condition: If the serialization fails to accurately represent the data graph's triples, validation results will be incorrect.

## Foundational Learning

- Concept: First-Order Logic (FOL) and its translation to TPTP format
  - Why needed here: SHACL2FOL relies on FOL theorem provers, requiring understanding of FOL syntax, semantics, and TPTP serialization for compatibility.
  - Quick check question: What is the difference between τ+(G) and τ-(G) in the context of data graph serialization?

- Concept: SHACL shape graphs and constraint components
  - Why needed here: The tool translates SHACL shapes, so understanding shape targets, constraint components, and recursive constraints is essential for correct usage and interpretation.
  - Quick check question: How does SHACL2FOL handle recursive constraints differently from non-recursive ones?

- Concept: Satisfiability, containment, and validation in formal logic
  - Why needed here: These are the core decision problems SHACL2FOL solves, requiring understanding of what it means for a FOL sentence to be satisfiable, and how containment is reduced to satisfiability.
  - Quick check question: Explain how SHACL2FOL reduces the containment checking problem to a satisfiability problem.

## Architecture Onboarding

- Component map:
  - SHACL Parser -> SCL Translator -> TPTP Serializer -> Theorem Prover Interface -> Result Parser

- Critical path:
  1. Parse SHACL input
  2. Translate to SCL
  3. Serialize to TPTP
  4. Invoke theorem prover
  5. Parse and return results

- Design tradeoffs:
  - FOL translation completeness vs. performance: Supporting all SHACL constraints increases translation complexity and theorem prover load
  - UNA encoding approaches: Pairwise inequalities are more universally compatible but scale poorly; "$distinct" type scales better but may have prover compatibility issues
  - Theorem prover selection: Different provers have different strengths; E is complete for FOL while Vampire has optimizations for specific fragments

- Failure signatures:
  - Parser errors: Malformed SHACL input causes parsing failures
  - Translation errors: Unsupported SHACL features trigger translation exceptions
  - Solver timeouts: Complex problems exceed theorem prover time limits
  - Incorrect results: Bugs in translation or serialization lead to wrong satisfiability/containment conclusions

- First 3 experiments:
  1. Test simple shape graph satisfiability with one shape and basic constraints
  2. Test shape graph containment with two simple, non-overlapping shape graphs
  3. Test validation with a small shape graph and data graph where the data clearly conforms to the shapes

## Open Questions the Paper Calls Out

### Open Question 1
- Question: How does SHACL2FOL's performance scale with large shape graphs and complex SHACL constraints?
- Basis in paper: [explicit] "Preliminary development testing has been successfully performed on small shape and data graphs. Due to the absence of an established benchmark of SHACL shapes, comprehensive scalability testing remains a non-trivial task and it is left for future work."
- Why unresolved: No comprehensive testing on large or complex shape graphs has been conducted yet.
- What evidence would resolve it: Systematic performance benchmarking with varying sizes and complexities of SHACL shape graphs, comparing runtime and memory usage.

### Open Question 2
- Question: Can SHACL2FOL be extended to handle all SHACL constraint components, including complex constraints on literals?
- Basis in paper: [explicit] "An implementation of the more complex SHACL constraints on literals is possible but time consuming. For this reason, among the constraints on literals, only the sh:NodeKind, constraint has been implemented."
- Why unresolved: The tool currently implements only a subset of SHACL constraints, particularly lacking complex literal constraints.
- What evidence would resolve it: Full implementation and testing of all SHACL constraint components, with validation against real-world SHACL use cases.

### Open Question 3
- Question: How does SHACL2FOL's approach compare to existing SHACL validators in terms of accuracy and efficiency?
- Basis in paper: [explicit] "While our approach does not aim to outperform existing validators, it is significant because it demonstrates how even SHACL validation can be represented and studied as a first-order logic satisfiability problem."
- Why unresolved: The tool is not designed to compete with existing validators, so no direct comparison has been made.
- What evidence would resolve it: Comparative analysis of SHACL2FOL against established SHACL validators on standard benchmark datasets, measuring both correctness and performance.

## Limitations
- Limited testing on small shape graphs only, with no comprehensive scalability testing
- Partial implementation of SHACL constraint components, particularly complex literal constraints
- No direct comparison with existing SHACL validators for accuracy or efficiency

## Confidence

- Translation mechanism: **High** confidence in core FOL translation functionality
- Scalability claims: **Medium** confidence due to limited testing scope
- Recursive constraint handling: **Low** confidence due to minimal discussion
- Performance claims: **Low** confidence without comprehensive benchmarks
- Integration reliability: **Medium** confidence based on theorem prover compatibility

## Next Checks

1. Test translation and satisfiability checking with recursive constraints to verify correct handling of self-referential shapes
2. Benchmark performance with progressively larger shape graphs (10, 50, 100 shapes) to assess scalability claims
3. Validate correctness by comparing SHACL2FOL results against known satisfiable/unsatisfiable shape graphs from SHACL test suites