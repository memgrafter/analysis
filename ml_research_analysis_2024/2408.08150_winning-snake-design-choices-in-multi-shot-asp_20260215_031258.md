---
ver: rpa2
title: 'Winning Snake: Design Choices in Multi-Shot ASP'
arxiv_id: '2408.08150'
source_url: https://arxiv.org/abs/2408.08150
tags:
- snake
- grid
- multi-shot
- path
- logic
- transformers
- self-attention
- retrieval-augmented-generation
- instruction-tuning
- parameter-efficient-finetuning
- mixture-of-experts
- chain-of-thought
core_contribution: This paper demonstrates the design and evaluation of five multi-shot
  ASP implementations for the game snake, where a snake navigates a grid to consume
  apples and grow. The game can be solved optimally by computing Hamiltonian cycles,
  a known NP-hard problem.
---

# Winning Snake: Design Choices in Multi-Shot ASP

## Quick Facts
- arXiv ID: 2408.08150
- Source URL: https://arxiv.org/abs/2408.08150
- Reference count: 3
- Primary result: Multi-shot ASP approaches leverage learned nogoods to outperform one-shot solving for large snake grids (14x14, 16x16), with ad hoc and assume strategies showing the most stable performance.

## Executive Summary
This paper demonstrates the design and evaluation of five multi-shot ASP implementations for the game snake, where a snake navigates a grid to consume apples and grow. The game can be solved optimally by computing Hamiltonian cycles, a known NP-hard problem. The authors implement five approaches—one-shot, ad hoc, preground, assume, and nogood—to solve this problem iteratively. In an empirical evaluation with grids up to 16x16, all methods guarantee winning the game, but one-shot outperforms others until resource limits (e.g., timeouts) are encountered. Multi-shot methods leverage learned nogoods and outperform one-shot for larger grids by reusing search progress, with assume and ad hoc showing the most stable performance. The results highlight trade-offs between simplicity, flexibility, and computational efficiency in multi-shot ASP design.

## Method Summary
The authors implement and compare five multi-shot ASP approaches (one-shot, ad hoc, preground, assume, nogood) for solving the snake game optimally via Hamiltonian cycles. The evaluation uses square grid sizes from 6×6 to 16×16, with 100 games per grid size. Apple and snake positions are managed as external atoms. The objective metrics are win/loose ratio (should be 100%), total steps to finish, and total computation time with 60-second timeout per iteration. The method involves iterative solving where each iteration requires finding Hamiltonian cycles with ASP, using different multi-shot techniques to manage external atoms and nogoods.

## Key Results
- All five approaches guarantee winning the game for even-sized grids by computing Hamiltonian cycles
- One-shot approach outperforms multi-shot approaches for smaller grids (6x6, 8x8) but degrades with timeouts for larger grids
- Multi-shot approaches show increasing advantage over one-shot for larger grids (14x14, 16x16) by reusing search progress
- Assume and ad hoc approaches demonstrate the most stable performance across all grid sizes

## Why This Works (Mechanism)

### Mechanism 1
- Claim: Multi-shot ASP can reuse learned nogoods across iterations to accelerate solving.
- Mechanism: During each iteration of the snake game, the ASP solver learns nogoods from failed search branches. In multi-shot solving, these nogoods persist and are reused in subsequent iterations, pruning the search space and avoiding redundant work.
- Core assumption: The problem structure (grid traversal and snake movement) remains similar enough across iterations that nogoods from one iteration are valid in the next.
- Evidence anchors:
  - [abstract]: "Multi-shot methods leverage learned nogoods and outperform one-shot for larger grids by reusing search progress"
  - [section]: "The multi-shot approaches could utilize the search progress from previous solving attempts, leading to a reduction of timeouts in the following iterations"
  - [corpus]: Weak evidence. No direct mention of nogood reuse in related papers.
- Break condition: If the snake's movement pattern changes drastically (e.g., large grid with sparse obstacles), nogoods may become less relevant and the advantage diminishes.

### Mechanism 2
- Claim: Pre-grounding all possible temporary rules reduces runtime overhead compared to ad hoc rule addition.
- Mechanism: By declaring all potential external atoms and rules upfront (via `#external prenext/2` and associated constraints), the system avoids repeated grounding during iterations. Temporary rules are simply toggled on/off via externals.
- Core assumption: The set of possible snake positions and movements is finite and known in advance, allowing complete pre-grounding.
- Evidence anchors:
  - [section]: "Pregrounding does not include the option to add rules on the fly since all possible changes are introduced once in the beginning"
  - [section]: "Preground might perform well on compact programs with lots of iterations, since in comparison to ad hoc no overhead is generated"
  - [corpus]: Weak evidence. No direct mention of pre-grounding trade-offs in related papers.
- Break condition: If the problem space grows too large (e.g., very high grid dimensions), pre-grounding may consume excessive memory or slow initial grounding.

### Mechanism 3
- Claim: Assumptions provide a flexible, rule-free way to fix atom truth values across iterations.
- Mechanism: Instead of manipulating externals or adding/removing rules, assumptions directly specify which atoms must be true/false for each solve call. This avoids modifying the program structure.
- Core assumption: The number of assumptions per iteration is manageable and does not introduce significant overhead in the solver.
- Evidence anchors:
  - [section]: "Assumption atoms do not require to be declared as such and they are provided as a list of atom/truth value assignments to the solve call"
  - [section]: "Handling atoms with complex terms in clingo can become convoluted quite fast, decreasing the readability of the code"
  - [corpus]: Weak evidence. No direct mention of assumption usage in related papers.
- Break condition: If assumptions become too numerous or complex, they may degrade solver performance or make the wrapper code harder to maintain.

## Foundational Learning

- Concept: Hamiltonian cycles in grid graphs
  - Why needed here: The snake game is won by ensuring every grid cell is reachable in each iteration, which is enforced by constructing Hamiltonian cycles.
  - Quick check question: Why can Hamiltonian cycles only be formed in grid graphs with an even number of vertices?

- Concept: Multi-shot vs. one-shot ASP solving
  - Why needed here: Multi-shot solving allows reusing learned search information (nogoods) across iterations, which is critical for performance in iterative problems like snake.
  - Quick check question: What is the main performance bottleneck that multi-shot solving addresses in iterative ASP problems?

- Concept: External atoms and assumptions in clingo
  - Why needed here: These mechanisms allow dynamic manipulation of truth values without modifying the core logic program, enabling different multi-shot strategies (ad hoc, preground, assume).
  - Quick check question: How do external atoms differ from assumptions in terms of persistence across solve calls?

## Architecture Onboarding

- Component map:
  Logic program (Algorithm 1) -> Wrapper (Algorithm 2) -> Strategy modules (Algorithms 3-8) -> Visualization (clingraph)

- Critical path:
  1. Initialize grid and externals
  2. Loop: Place apple, set snake head, enforce path constraints via chosen strategy
  3. Solve and extract path
  4. Update snake position and step counter
  5. Repeat until snake reaches maximum length or no path is found

- Design tradeoffs:
  - One-shot: Simple, stable, but slow for large grids due to repeated grounding
  - Ad hoc: Flexible, but requires careful rule management and may introduce overhead
  - Preground: Fast for small rule sets, but memory-intensive for large grids
  - Assume: Clean interface, but may become unwieldy with complex terms
  - Nogood: Most expressive, but requires advanced API knowledge and careful first-model handling

- Failure signatures:
  - Timeout in early iterations: Indicates insufficient reuse of search progress; consider switching to multi-shot
  - Memory exhaustion: Likely from pre-grounding too many rules; consider ad hoc or assume
  - Incorrect paths: Check assumption/external propagation logic in the wrapper

- First 3 experiments:
  1. Run 6x6 grid with one-shot to verify basic functionality and measure baseline performance
  2. Run 6x6 grid with each multi-shot strategy to compare step counts and solve times
  3. Scale to 10x10 grid and observe when one-shot begins to degrade compared to multi-shot approaches

## Open Questions the Paper Calls Out

### Open Question 1
- Question: Does the performance advantage of multi-shot ASP over one-shot persist in even larger grid sizes (e.g., 20x20 or beyond) under similar timeout constraints?
- Basis in paper: [inferred] The paper notes that multi-shot approaches show increasing advantage over one-shot for larger grids (14x14, 16x16), but does not test beyond 16x16.
- Why unresolved: The evaluation stops at 16x16 grids, leaving uncertainty about scalability to much larger instances.
- What evidence would resolve it: Experimental results comparing one-shot vs. multi-shot ASP performance on grids larger than 16x16, with consistent timeout constraints, would clarify whether the trend continues.

### Open Question 2
- Question: How does the performance of multi-shot ASP compare to other computational approaches (e.g., SAT solvers, heuristic-based AI) for solving the snake game?
- Basis in paper: [explicit] The authors mention that various AI approaches, including search algorithms and reinforcement learning, have been applied to the snake game, but do not provide a comparative analysis.
- Why unresolved: The paper focuses solely on ASP implementations without benchmarking against other methods.
- What evidence would resolve it: A comparative study of multi-shot ASP against SAT solvers, heuristic algorithms, or machine learning approaches on the same snake game instances would establish relative performance.

### Open Question 3
- Question: Can the conservative strategy be extended to handle arbitrary snake starting positions (not just corner starts) while maintaining winning guarantees?
- Basis in paper: [inferred] The paper notes that the current strategies rely on a continuous setting and cannot handle arbitrary snake placements, as seen in Figure 1(d).
- Why unresolved: The authors explicitly state this limitation but do not propose or test solutions for arbitrary starting positions.
- What evidence would resolve it: A modified conservative strategy that successfully solves snake games with arbitrary starting positions, along with experimental validation, would address this limitation.

### Open Question 4
- Question: What is the impact of using different problem formulations (e.g., the alternative MHS definition in Figure 2(c)) on the performance and solution quality of multi-shot ASP?
- Basis in paper: [explicit] The authors mention an alternative problem formulation that could lead to shorter paths while still guaranteeing a win, but do not explore its implications.
- Why unresolved: The paper introduces the alternative formulation but does not implement or evaluate it.
- What evidence would resolve it: Implementing and testing the alternative problem formulation in multi-shot ASP, comparing solution lengths and computation times to the original approach, would clarify its benefits.

## Limitations

- Performance claims rely on empirical results that may not generalize beyond tested grid sizes (6x6 to 16x16)
- The claim that all methods guarantee winning is theoretically sound but not verified for non-square or irregularly shaped grids
- Trade-offs between different multi-shot strategies are described qualitatively without comprehensive quantitative benchmarks

## Confidence

- **High**: One-shot approach correctly implements Hamiltonian cycle search and guarantees wins for even-sized grids. Multi-shot approaches can reuse learned nogoods.
- **Medium**: Multi-shot methods outperform one-shot for larger grids when timeouts occur. Ad hoc and assume approaches show most stable performance.
- **Low**: The paper doesn't provide comprehensive analysis of memory usage differences between preground and ad hoc approaches, nor does it characterize the overhead introduced by complex assumption lists.

## Next Checks

1. **Scalability test**: Extend experiments beyond 16x16 grids to identify the precise breakpoint where multi-shot approaches consistently outperform one-shot, measuring both time and memory consumption.
2. **Robustness verification**: Test the implementations on non-square grids and grids with obstacles to verify the claim that all methods guarantee winning under varied conditions.
3. **Memory profiling**: Compare memory usage patterns of preground vs ad hoc approaches during execution to quantify the stated trade-off between initialization overhead and iteration efficiency.