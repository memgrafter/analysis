---
ver: rpa2
title: Refutation of Spectral Graph Theory Conjectures with Search Algorithms)
arxiv_id: '2409.18626'
source_url: https://arxiv.org/abs/2409.18626
tags:
- conjectures
- graffiti
- graph
- search
- algorithms
- transformers
- self-attention
- retrieval-augmented-generation
- instruction-tuning
- parameter-efficient-finetuning
- mixture-of-experts
- chain-of-thought
core_contribution: The authors propose using search algorithms to refute spectral
  graph theory conjectures from Graffiti, aiming to address the limitations of exhaustive
  generation (small graph sizes) and deep reinforcement learning (long computation
  times). They apply multiple search algorithms (NMCS, LNMCS, NRPA, UCT, GBFS, BEAM,
  GRAVE, RAVE) to a selection of 13 already refuted and several open conjectures from
  Graffiti.
---

# Refutation of Spectral Graph Theory Conjectures with Search Algorithms)

## Quick Facts
- arXiv ID: 2409.18626
- Source URL: https://arxiv.org/abs/2409.18626
- Authors: Milo Roucairol; Tristan Cazenave
- Reference count: 40
- Authors propose using search algorithms to refute spectral graph theory conjectures from Graffiti, achieving refutation of 12/13 known conjectures in seconds.

## Executive Summary
This paper addresses the challenge of refuting spectral graph theory conjectures by proposing search algorithms as a faster alternative to exhaustive generation and deep reinforcement learning. The authors apply multiple search algorithms (NMCS, LNMCS, NRPA, UCT, GBFS, BEAM, GRAVE, RAVE) to 13 already-refuted and several open conjectures from the Graffiti system. Their results show that search algorithms can refute known conjectures in seconds, with GBFS, NMCS, and NRPA identified as particularly effective approaches. Notably, they also refute conjecture 197, which was previously open, demonstrating the potential of these methods to advance automated conjecture generation and refutation in mathematics.

## Method Summary
The authors implement a refutation framework that incrementally builds graphs while evaluating them against conjecture properties using spectral graph theory invariants. They apply eight different search algorithms (NMCS, LNMCS, NRPA, UCT, GBFS, BEAM, GRAVE, RAVE) with specific parameters to a selection of 13 already-refuted and several open conjectures from the Graffiti system. The algorithms build graphs edge by edge, using evaluation functions based on spectral properties to guide the search toward counter-examples. The implementation is done in Rust 1.59 and runs on Intel Core i5-6600K 3.50GHz hardware.

## Key Results
- Search algorithms successfully refute 12 out of 13 already-refuted conjectures in seconds
- Conjecture 197, previously open, is refuted using these methods
- GBFS, NMCS, and NRPA are identified as particularly effective algorithms
- Refutation times range from instantaneous to a few hundred seconds depending on the conjecture
- Search algorithms prove hundreds of times faster than Wagner's deep cross-entropy method

## Why This Works (Mechanism)

### Mechanism 1
- Claim: Search algorithms can find counter-examples faster than exhaustive generation or deep RL.
- Mechanism: By building graphs incrementally and using evaluation functions that directly reflect the conjecture's property, search algorithms explore the space more efficiently, focusing on promising regions.
- Core assumption: The evaluation function is smooth enough that greedy or MCTS strategies can navigate toward counter-examples.
- Evidence anchors:
  - [abstract] "we propose to use search algorithms to address these shortcomings to find potentially large counter-examples to spectral graph theory conjectures in seconds."
  - [section] "Our search algorithms can rapidly generate larger refutation graphs."
  - [corpus] Weak - corpus neighbors focus on automated conjecturing, not refutation methods.
- Break condition: If the evaluation function is too noisy or discontinuous, greedy strategies fail and MCTS becomes inefficient.

### Mechanism 2
- Claim: Different search algorithms are suited to different conjecture types.
- Mechanism: GBFS works well when the score function is relatively smooth and large graphs are needed quickly; NRPA excels when a repeating pattern leads to counter-examples; NMCS/LNMCS balance exploration and exploitation.
- Core assumption: The structure of the search space and the conjecture's definition influence which algorithm performs best.
- Evidence anchors:
  - [section] "We can identify three algorithms that seem more effective... GBFS which is overall faster but was not able to refute conjectures in ?? and struggled on Graffiti 30, NRPA which is very efficient when a repeating pattern refutes a conjecture, and LNMCS/NMCS which managed to be slightly faster than NRPA on Graffiti 29 and 301"
  - [section] "It seems that not one single algorithm is able to solve all of sample of conjectures we selected, and using different approaches is required to adapt to the variety of problems"
  - [corpus] Weak - corpus neighbors don't discuss algorithm selection for refutation.
- Break condition: If multiple algorithms fail, the conjecture may be true or require a fundamentally different approach.

### Mechanism 3
- Claim: Starting the search from restricted graph classes can accelerate refutation.
- Mechanism: Instead of building any graph, constraining the search to trees or K3-free graphs reduces the branching factor and focuses on structures likely to violate the conjecture.
- Core assumption: The conjecture's truth often hinges on properties that are more extreme in certain graph classes.
- Evidence anchors:
  - [section] "Trying to build trees even when the conjecture is applied on any graph can also be helpful as it reduces the amount of possible builds greatly and focuses on a sub-type of graphs that often features extreme properties over the spectral invariants"
  - [section] "We tried both generating trees and then any graph on multiple conjectures"
  - [corpus] Weak - corpus neighbors focus on conjecture generation, not refutation with restricted classes.
- Break condition: If the true counter-example doesn't belong to the restricted class, this strategy will miss it.

## Foundational Learning

- Concept: Spectral graph theory invariants (eigenvalues, Laplacian, adjacency, distance matrices)
  - Why needed here: The refutation algorithms rely on evaluating these invariants to guide the search.
  - Quick check question: What is the second smallest eigenvalue of the Laplacian matrix called, and what does it measure?
- Concept: Graph building games (incremental edge/node addition)
  - Why needed here: The search algorithms explore the space by constructing graphs step by step.
  - Quick check question: In the refutation setting, what is the "move" at each step of the game?
- Concept: Monte Carlo Tree Search (MCTS) and variants (UCT, RAVE, GRAVE, NMCS, LNMCS, NRPA)
  - Why needed here: These are the core algorithms used to explore the refutation space efficiently.
  - Quick check question: What is the key difference between UCT and NMCS in how they balance exploration and exploitation?

## Architecture Onboarding

- Component map:
  - Conjecture parser -> Graph builder -> Evaluation engine -> Search algorithm -> Result logger
- Critical path: Conjecture → Graph builder → Evaluation engine → Search algorithm → Refutation result
- Design tradeoffs:
  - Exhaustive vs. heuristic search: Exhaustive is guaranteed but slow; heuristics are fast but may miss counter-examples
  - Single vs. multiple algorithms: Using one algorithm is simpler but less robust; multiple algorithms increase coverage but add complexity
  - Restricted vs. unrestricted graph classes: Restricted classes speed up search but may miss counter-examples
- Failure signatures:
  - Algorithm fails to find counter-example despite many runs: Conjecture may be true, or the algorithm is not suited to this conjecture
  - Algorithm finds counter-example but evaluation is incorrect: Bug in evaluation engine or graph builder
  - Algorithm runs forever without progress: Evaluation function is too expensive or search space is too large
- First 3 experiments:
  1. Run GBFS on a simple, already-refuted conjecture (e.g., Graffiti 29) to verify basic functionality
  2. Run multiple algorithms on the same conjecture and compare refutation times to identify best performers
  3. Restrict the graph class (e.g., trees only) and re-run algorithms to test speedup vs. coverage tradeoff

## Open Questions the Paper Calls Out

### Open Question 1
- Question: Can the proposed search algorithms refute additional open conjectures from Graffiti beyond conjecture 197?
- Basis in paper: [explicit] The authors mention they were unable to refute most open conjectures except for 197, and suggest this might be due to either the algorithms not being strong enough or the conjectures being true.
- Why unresolved: The paper only tested a selection of conjectures and did not exhaustively attempt to refute all open conjectures. The authors suggest that either the algorithms need improvement or some conjectures might be true.
- What evidence would resolve it: Applying the search algorithms to all remaining open conjectures from Graffiti, documenting which ones can be refuted and the time/resources required.

### Open Question 2
- Question: How do the performance and effectiveness of the search algorithms compare to other methods for refuting graph theory conjectures, such as deep reinforcement learning or exhaustive generation?
- Basis in paper: [explicit] The authors compare their search algorithms to Wagner's deep cross-entropy method and exhaustive generation, noting that their algorithms are significantly faster. However, a comprehensive comparison with other refutation methods is not provided.
- Why unresolved: The paper focuses on comparing different search algorithms but does not include a thorough comparison with other refutation approaches in terms of speed, resource usage, or success rate across various types of conjectures.
- What evidence would resolve it: Conducting a benchmark study that applies multiple refutation methods (including search algorithms, deep reinforcement learning, and exhaustive generation) to a standardized set of conjectures and comparing their performance metrics.

### Open Question 3
- Question: What are the theoretical limits of using search algorithms for refuting graph theory conjectures, particularly in terms of graph size and complexity of the conjecture?
- Basis in paper: [inferred] The authors note limitations such as the computational cost of eigenvalue calculations for large graphs and the dependency on the shape of the score function. However, they do not provide a comprehensive analysis of the theoretical boundaries of these methods.
- Why unresolved: The paper demonstrates practical applications and success cases but does not delve into the theoretical analysis of when and why these methods might fail or reach their limits.
- What evidence would resolve it: Developing a theoretical framework that characterizes the types of conjectures and graph properties for which search algorithms are most effective, and identifying the computational complexity barriers that limit their application.

## Limitations
- The paper doesn't fully specify which spectral invariants are used for evaluation, creating reproducibility challenges
- Performance degrades for conjectures requiring NP-hard computations or very large graphs (over size 300)
- The approach may miss counter-examples if they don't belong to restricted graph classes

## Confidence
- High confidence: Search algorithms can refute known conjectures faster than Wagner's method (12/13 successful, seconds vs. much longer)
- Medium confidence: GBFS, NMCS, and NRPA are the most effective algorithms (supported by results but limited test set)
- Low confidence: Restricted graph classes consistently improve performance (limited empirical validation)

## Next Checks
1. Implement a benchmark suite with publicly available conjecture definitions and exact evaluation functions to enable independent verification of refutation times and success rates
2. Systematically vary evaluation function parameters (e.g., different spectral invariants) to determine sensitivity of refutation success to these choices
3. Conduct head-to-head comparisons on a larger set of conjectures (including those requiring NP-hard computations) to better understand which algorithm-graph type combinations are most robust across the full space of possible conjectures