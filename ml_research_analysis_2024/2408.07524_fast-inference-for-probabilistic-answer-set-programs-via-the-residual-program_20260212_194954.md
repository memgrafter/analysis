---
ver: rpa2
title: Fast Inference for Probabilistic Answer Set Programs via the Residual Program
arxiv_id: '2408.07524'
source_url: https://arxiv.org/abs/2408.07524
tags:
- program
- answer
- probabilistic
- query
- path
- transformers
- self-attention
- retrieval-augmented-generation
- instruction-tuning
- parameter-efficient-finetuning
- mixture-of-experts
- chain-of-thought
core_contribution: The paper addresses the problem of slow inference in Probabilistic
  Answer Set Programming (PASP) by proposing a method to speed up query processing
  through residual program extraction. The core method leverages SLG resolution to
  identify and remove parts of a PASP program that do not influence the probability
  of a given query, resulting in a smaller residual program.
---

# Fast Inference for Probabilistic Answer Set Programs via the Residual Program

## Quick Facts
- arXiv ID: 2408.07524
- Source URL: https://arxiv.org/abs/2408.07524
- Authors: Damiano Azzolini; Fabrizio Riguzzi
- Reference count: 9
- Primary result: Residual program extraction significantly speeds up PASP inference by removing irrelevant program parts

## Executive Summary
This paper introduces a method to accelerate inference in Probabilistic Answer Set Programming (PASP) by extracting and using a residual program. The approach leverages SLG resolution and tabling to identify parts of the PASP program that do not influence a given query's probability, removing them to create a smaller residual program. Experiments on graph datasets demonstrate substantial speedups, with solvable instances increasing from 10-20 to 60-100 and tree decomposition size reducing from thousands to tens of bags. The method preserves probability bounds and adds negligible overhead to the inference process.

## Method Summary
The method converts PASP to Prolog with tabled predicates, encoding probabilistic facts as pairs of rules. Using SWI Prolog's call residual program/2 predicate with SLG resolution and tabling, the algorithm extracts the residual program for a given query by identifying the relevant sub-graph. The probabilistic fact pairs are then replaced with actual facts, and the resulting residual program is used for inference with aspmc to compute query probabilities. This approach reduces grounding size and speeds up inference while preserving probability bounds for queries in OLON-free programs.

## Key Results
- Speedup from 10-20 to 60-100 solvable instances across graph datasets
- Reduction in tree decomposition bags from thousands to tens
- Negligible (<1 second) overhead for residual program extraction
- Preservation of upper and lower probability bounds for OLON-free programs

## Why This Works (Mechanism)

### Mechanism 1
- Claim: The residual program removes irrelevant parts of the PASP, reducing the size of the grounding required for inference.
- Mechanism: By leveraging SLG resolution and tabling, the algorithm identifies which rules and facts do not influence the query's probability. These irrelevant parts are removed to form the residual program, which is then grounded and used for inference instead of the full program.
- Core assumption: The Well-founded Semantics (WFS) is relevant for normal programs without Odd Loops Over Negation (OLON), meaning the truth value of an atom depends only on the truth values of atoms in its relevant sub-graph.
- Evidence anchors:
  - [abstract] "The residual program does not contain the parts of the program that do not influence the probability."
  - [section] "The residual program represents the part of the program that is needed to compute the probability of a query and it is often smaller than the original program."
  - [corpus] Weak; no direct mention of grounding reduction in neighbors.
- Break condition: If the program contains OLON, the WFS is not relevant, and the residual program extraction may not correctly identify irrelevant parts.

### Mechanism 2
- Claim: The residual program preserves the probability bounds of the query, ensuring correct inference results.
- Mechanism: The residual program is constructed such that its answer sets projected onto its Herbrand base coincide with the answer sets of the original program. This preservation ensures that the upper and lower probability bounds computed from the residual program are the same as those from the original program.
- Core assumption: The translation of probabilistic facts into pairs of rules and the subsequent residual program extraction maintain the probabilistic dependencies needed for correct probability computation.
- Evidence anchors:
  - [section] "Theorem 2: Given a PASP P together with its residual program P r q for a query q, let P(q) be the upper probability of q in P and P ′(q) be the upper probability of q in P r q . Then P(q) = P ′(q)."
  - [corpus] No direct evidence in neighbors.
- Break condition: If the translation of probabilistic facts into rules is incorrect or if the residual program extraction algorithm has a bug, the probability bounds may not be preserved.

### Mechanism 3
- Claim: The time overhead of residual program extraction is negligible compared to the inference time savings.
- Mechanism: Extracting the residual program using SLG resolution and tabling takes less than one second, as stated in the experiments section. This small overhead is outweighed by the significant reduction in grounding size and subsequent inference time.
- Core assumption: The residual program extraction process is efficient and the time taken is orders of magnitude smaller than the inference time on the full program.
- Evidence anchors:
  - [section] "The extraction takes less than one second, so we decided to report only the total execution times, without indicating the two components for aspmcr."
  - [corpus] No direct evidence in neighbors.
- Break condition: If the residual program extraction becomes inefficient for larger programs or if the overhead increases disproportionately, the time savings may be negated.

## Foundational Learning

- Concept: SLG Resolution and Tabling
  - Why needed here: SLG resolution with tabling is used to compute the residual program by exploring the relevant sub-graph of the program for a given query.
  - Quick check question: How does SLG resolution differ from SLD resolution, and why is tabling important for computing the residual program?

- Concept: Well-founded Semantics (WFS)
  - Why needed here: WFS determines the truth values of atoms in normal programs without OLON, which is essential for identifying the relevant sub-graph and computing the residual program.

- Concept: Odd Loops Over Negation (OLON)
  - Why needed here: OLON programs are those where the WFS is not relevant, and the residual program extraction method may fail to preserve probability bounds in such cases.

- Concept: Probabilistic Answer Set Programming (PASP)
  - Why needed here: PASP combines answer set programming with probabilistic reasoning, and the paper focuses on speeding up inference in this paradigm.

- Concept: Credal Semantics
  - Why needed here: The paper uses Credal Semantics for PASP, which provides upper and lower probability bounds for queries, and the residual program preserves these bounds.

- Concept: Tree Decomposition
  - Why needed here: Tree decomposition is used to analyze the structure of the residual program and measure the reduction in program size achieved by the method.

## Architecture Onboarding

### Component Map
PASP program -> SWI Prolog conversion -> call residual program/2 -> Residual program -> aspmc inference -> Query probability

### Critical Path
Convert PASP to Prolog with tabled predicates and probabilistic fact pairs -> Extract residual program using call residual program/2 -> Replace probabilistic fact pairs with actual facts -> Use aspmc to compute query probability

### Design Tradeoffs
- Tabling vs. no tabling: Tabling enables efficient residual program extraction but adds memory overhead
- Probabilistic fact pairs vs. direct encoding: Fact pairs preserve probabilistic dependencies but increase program size
- Residual program vs. full program: Residual program reduces grounding size but requires additional extraction step

### Failure Signatures
- No speedup observed: Check if program is normal without OLON, verify query actually uses all parts of program
- Residual program extraction taking too long: Ensure tabling is enabled, use tnot instead of not
- Probability bounds not preserved: Check for OLON in program, verify correct translation of probabilistic facts

### First Experiments
1. Test residual program extraction on a small OLON-free PASP program and measure speedup
2. Verify probability bounds preservation by comparing results from residual and full programs
3. Measure and report separate timings for residual program extraction and inference

## Open Questions the Paper Calls Out

### Open Question 1
- Question: What is the impact of residual program extraction on PASP systems beyond the Credal Semantics, such as LPMN, P-log, or smProbLog?
- Basis in paper: [explicit] The paper discusses related works including LPMN, P-log, and smProbLog, noting that residual program extraction may help speed up inference in these alternative semantics, and suggests exploring this as future work.
- Why unresolved: The paper does not provide experimental results or theoretical analysis for these alternative semantics.
- What evidence would resolve it: Empirical studies or theoretical proofs demonstrating the effectiveness of residual program extraction on these PASP systems.

### Open Question 2
- Question: How does the residual program extraction method scale with increasing problem complexity and larger datasets?
- Basis in paper: [inferred] The paper presents experiments on graph datasets with increasing sizes, showing significant improvements in speed and reduction in program size. However, it does not explore very large-scale problems or provide insights into scalability limits.
- Why unresolved: The experiments are limited to specific datasets and sizes, and do not address extreme cases or very large-scale applications.
- What evidence would resolve it: Comprehensive experiments on larger and more diverse datasets, including performance analysis and scalability testing.

### Open Question 3
- Question: Can the residual program extraction method be adapted for other logic programming paradigms or systems that do not use SLG resolution?
- Basis in paper: [explicit] The paper mentions that the approach is general and can be built on top of any Prolog system that supports SLG resolution, and discusses related works like s(ASP) and s(CASP) which use different resolution techniques.
- Why unresolved: The paper does not provide experimental results or theoretical analysis for adapting the method to other paradigms or systems.
- What evidence would resolve it: Successful implementation and testing of the residual program extraction method on other logic programming systems or paradigms.

## Limitations

- The method is only guaranteed to preserve probability bounds for OLON-free programs
- The impact on grounding size is inferred rather than measured directly
- Experiments are limited to graph datasets, with no evaluation on other domains

## Confidence

- Speedup claim: High (quantitative results across multiple datasets)
- Negligible overhead claim: Medium (lack of detailed timing data)
- Probability bounds preservation: High (formal theorem for OLON-free programs)

## Next Checks

1. Test the approach on a small program containing OLON to confirm the claim that residual extraction fails in such cases.
2. Measure and report separate timings for residual program extraction and inference to verify the overhead claim.
3. Apply the method to a non-graph domain (e.g., a rule-based medical diagnosis program) to assess generalizability beyond the evaluated datasets.