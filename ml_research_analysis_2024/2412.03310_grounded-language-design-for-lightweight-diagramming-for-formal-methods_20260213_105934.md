---
ver: rpa2
title: Grounded Language Design for Lightweight Diagramming for Formal Methods
arxiv_id: '2412.03310'
source_url: https://arxiv.org/abs/2412.03310
tags:
- alloy
- default
- diagram
- visualizer
- these
- transformers
- self-attention
- retrieval-augmented-generation
- instruction-tuning
- parameter-efficient-finetuning
- mixture-of-experts
- chain-of-thought
core_contribution: This paper presents Cope and Drag (CnD), a lightweight diagramming
  language designed for formal methods tools like Alloy and Forge. CnD addresses the
  gap between domain-agnostic default visualizers and complex custom visualization
  tools by providing a middle ground that captures essential domain information for
  effective diagramming.
---

# Grounded Language Design for Lightweight Diagramming for Formal Methods

## Quick Facts
- arXiv ID: 2412.03310
- Source URL: https://arxiv.org/abs/2412.03310
- Authors: Siddhartha Prasad; Ben Greenman; Tim Nelson; Shriram Krishnamurthi
- Reference count: 40
- Key outcome: CnD diagrams improve user understanding to 62.75% correctness vs 48.04% for default visualizers

## Executive Summary
This paper introduces Cope and Drag (CnD), a lightweight diagramming language designed to bridge the gap between domain-agnostic default visualizers and complex custom visualization tools for formal methods. CnD addresses a critical need in lightweight formal methods tools like Alloy and Forge, where users struggle to understand model finder output through default visualizations. The language is grounded in cognitive science principles and informed by analysis of student-created visualizations, implementing a small set of orthogonal primitives that enable incremental refinement of model finder output into more effective diagrams.

The evaluation demonstrates that CnD significantly improves user understanding of formal methods instances compared to default visualizers, with participants correctly answering 62.75% of questions versus 48.04% for default visualizers. Critically, CnD maintains robustness to bad-instances by either producing error messages or structured diagrams that do not mask specification errors, addressing a key failure mode of custom visualizations. The language implements three core operations—relative positioning via cyclic/orientation constraints, grouping constraints, and styling directives—that cover essential diagramming needs while maintaining simplicity and ease of use.

## Method Summary
The method involves designing CnD based on cognitive science principles of visualization and analysis of student-created visualizations from Forge courses. The language is implemented as a domain-specific language that refines Alloy Default Visualizer output through three orthogonal primitives: cyclic and orientation constraints for relative positioning, grouping constraints for organizing related elements, and directives for styling and iconography. Evaluation was conducted through three participant studies using the Prolific platform, comparing CnD diagrams against default Alloy visualizers on comprehension tasks using student projects from Forge courses (2022-2024).

## Key Results
- Participants correctly answered 62.75% of questions with CnD diagrams versus 48.04% with default visualizers
- Pictorial directives showed positive trends in comprehension but did not achieve statistical significance
- CnD maintains robustness to bad-instances by producing error messages or structured diagrams that don't mask specification errors
- The incremental refinement approach allows users to start with default visualizations and add refinements as needed

## Why This Works (Mechanism)

### Mechanism 1
- Claim: CnD's incremental refinement approach enables users to gradually improve visualizations without needing full custom visualization upfront
- Mechanism: By building on Alloy Default Visualizer output, empty CnD programs produce the same output as Sterling, allowing users to apply constraints and directives incrementally as needed
- Core assumption: Users benefit from starting with basic visualizations and adding refinements rather than building custom visualizations from scratch
- Evidence anchors:
  - [abstract] "We need a language to capture essential domain information for lightweight diagramming"
  - [section 3.3] "Critically, CnD refines an Alloy Default Visualizer output. Thus, the user can apply it incrementally"
  - [corpus] Weak evidence - related papers focus on different diagramming approaches without directly addressing incremental refinement in formal methods

### Mechanism 2
- Claim: CnD prevents silent failure modes that plague custom visualizations by maintaining information visibility
- Mechanism: Since CnD only refines existing Alloy Default Visualizer output rather than replacing it entirely, it cannot hide information about bad-instances
- Core assumption: Preserving visibility of all instance information is critical for formal methods exploration and debugging
- Evidence anchors:
  - [abstract] "Critically, CnD maintains robustness to bad-instances by either producing error messages or structured diagrams that do not mask specification errors"
  - [section 4] "In contrast, a custom visualization needs to be sensitive to bad-instances and not misrepresent them or, worse, accidentally suppress the way in which they are bad"
  - [corpus] Weak evidence - related papers discuss visualization but don't specifically address bad-instance handling in formal methods contexts

### Mechanism 3
- Claim: CnD's orthogonal primitive set covers essential diagramming operations identified through cognitive science principles
- Mechanism: The language implements three core operations (relative positioning via cyclic/orientation constraints, grouping constraints, and styling directives) that map directly to identified diagramming needs
- Core assumption: A small set of well-chosen primitives can effectively capture most diagramming requirements for formal methods
- Evidence anchors:
  - [section 2.1.4] "From the above literature, we identify that users require the following operations: Relative Positioning, Grouping, Styling"
  - [section 3.1] "CnD implements the diagramming operations identified in section 2, and applies them to Alloy Default Visualizer-like directed graphs"
  - [corpus] Weak evidence - related papers discuss diagramming tools but don't specifically analyze cognitive science principles for formal methods visualization

## Foundational Learning

- Concept: SAT solvers and model finding in formal methods
  - Why needed here: Understanding how Alloy and Forge use SAT solvers to generate instances is crucial for grasping why visualization matters
  - Quick check question: What distinguishes lightweight formal methods tools like Alloy from traditional verification tools?

- Concept: Cognitive science principles of visualization (pre-attentive processing, Gestalt principles)
  - Why needed here: These principles inform the design of effective diagrams and explain why default visualizations fail
  - Quick check question: How do the Gestalt principles of proximity and similarity influence diagram effectiveness?

- Concept: The distinction between specifications, instances, and bad-instances
  - Why needed here: This distinction is fundamental to understanding the lightweight formal methods process and why bad-instance handling matters
  - Quick check question: What is a "bad-instance" and why is it important for formal methods tools to handle them correctly?

## Architecture Onboarding

- Component map:
  - Parser -> Constraint Solver -> Layout Engine -> Visualizer Integration
  - Directive Processor (parallel to main pipeline)

- Critical path:
  1. User writes CnD specification
  2. Parser converts spec to internal representation
  3. Constraints checked for consistency (static analysis)
  4. If consistent, constraints added to solver incrementally
  5. Solver checks if instance satisfies constraints
  6. If satisfied, WebCola generates layout
  7. Visualizer renders diagram with applied directives

- Design tradeoffs:
  - Hard vs soft constraints: CnD uses hard constraints to prevent misleading diagrams, unlike WebCola's soft constraints
  - Integration vs standalone: CnD lives in visualizer rather than spec language for portability but creates coupling
  - Expressiveness vs simplicity: Small primitive set covers most needs but may not handle all domain-specific requirements

- Failure signatures:
  - Constraint inconsistency errors: Occur when same field has conflicting layout directions
  - Unsatisfiable constraint errors: Instance cannot satisfy specified constraints
  - Layout generation failures: WebCola cannot produce layout (should be rare with proper constraint checking)

- First 3 experiments:
  1. Try empty CnD program on simple Alloy spec to verify it produces default visualization
  2. Add cyclic constraint to ring-spec example to verify circular layout works
  3. Add grouping constraint to tree-spec to verify node grouping functionality

## Open Questions the Paper Calls Out

### Open Question 1
- Question: How would CnD perform with users who have significant experience in formal methods and Alloy, compared to novice users?
- Basis in paper: [inferred] The evaluation section acknowledges that study participants had prior programming experience but not necessarily formal methods expertise, noting that "effects on understanding could differ for users with more experience in these areas."
- Why unresolved: The current evaluation only tested novice users without formal methods background, leaving a gap in understanding how experienced users would interact with and benefit from CnD.
- What evidence would resolve it: A controlled study comparing experienced formal methods practitioners with novice users, measuring their effectiveness in understanding and debugging specifications using CnD versus traditional visualizers.

### Open Question 2
- Question: Can CnD constraints and directives be automatically generated from specification semantics rather than requiring manual annotation?
- Basis in paper: [inferred] The paper mentions that CnD programs currently reside in the visualizer and discusses the possibility of extending spec languages to include views, but doesn't explore automatic generation of CnD specifications.
- Why unresolved: While the paper demonstrates the effectiveness of manually created CnD specifications, it doesn't investigate whether the semantic structure of specifications could be analyzed to automatically derive appropriate diagramming constraints.
- What evidence would resolve it: Development and evaluation of an automated CnD generation system that extracts layout constraints and styling directives from Alloy/Forge specifications, measuring its effectiveness against manually created specifications.

### Open Question 3
- Question: How does CnD handle very large specifications with hundreds or thousands of elements, and what are the scalability limits?
- Basis in paper: [inferred] While the paper mentions that users struggle with large instances in default visualizers, it doesn't explicitly test CnD's performance with very large specifications or discuss its scalability characteristics.
- Why unresolved: The evaluation focuses on small to medium-sized examples, and while the paper claims CnD is lightweight, there's no empirical data on its performance with large-scale specifications.
- What evidence would resolve it: Systematic testing of CnD with increasingly large specifications, measuring performance metrics (rendering time, memory usage, constraint solving time) and user comprehension metrics to identify scalability thresholds.

## Limitations
- Evaluation sample sizes are limited (26 participants in Study 2, 30 in Study 3), affecting generalizability
- Pictorial directive improvements showed positive trends but lacked statistical significance
- The three primitive operations may not cover all domain-specific visualization requirements
- No empirical data on CnD's performance with very large specifications (100+ elements)

## Confidence
- High Confidence: The core mechanism of incremental refinement building on Alloy Default Visualizer output is well-established through the implementation and works as described
- Medium Confidence: The claim that CnD prevents bad-instance masking is supported by the design but would benefit from more extensive testing with diverse specification errors
- Medium Confidence: The evaluation results showing improved comprehension are statistically significant but limited by sample size and potential selection bias

## Next Checks
1. **Scalability Testing**: Evaluate CnD performance and usability with larger specifications containing 100+ relations and complex constraint structures to identify potential scalability limitations
2. **Cross-Domain Applicability**: Test CnD with specifications from domains beyond the current examples (e.g., distributed systems, database schemas) to validate the generality of the three primitive operations
3. **Longitudinal Study**: Conduct a longitudinal study tracking users as they progressively refine diagrams over multiple sessions to validate the claimed benefits of incremental refinement approach