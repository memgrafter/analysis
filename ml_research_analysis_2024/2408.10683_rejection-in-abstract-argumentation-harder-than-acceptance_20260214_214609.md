---
ver: rpa2
title: 'Rejection in Abstract Argumentation: Harder Than Acceptance?'
arxiv_id: '2408.10683'
source_url: https://arxiv.org/abs/2408.10683
tags:
- extension
- arguments
- then
- rejection
- argumentation
- transformers
- self-attention
- retrieval-augmented-generation
- instruction-tuning
- parameter-efficient-finetuning
- mixture-of-experts
- chain-of-thought
core_contribution: This paper introduces rejection conditions in abstract argumentation
  frameworks, where each argument is associated with a logic program specifying when
  it should be rejected. The authors analyze the computational complexity of decision
  and reasoning problems under various semantics (admissible, stable, complete, semi-stable,
  stage) and for different classes of programs (simple, propositional/tight, disjunctive).
---

# Rejection in Abstract Argumentation: Harder Than Acceptance?

## Quick Facts
- arXiv ID: 2408.10683
- Source URL: https://arxiv.org/abs/2408.10683
- Reference count: 40
- Primary result: Rejection conditions in abstract argumentation frameworks are strictly harder than acceptance conditions, yielding problems at higher levels of the polynomial hierarchy (Σ₂ to Σ₄)

## Executive Summary
This paper introduces rejection conditions to abstract argumentation frameworks, where each argument is associated with a logic program that specifies when it should be rejected. The authors systematically analyze the computational complexity of various decision and reasoning problems under different argumentation semantics (admissible, stable, complete, semi-stable, stage) and for different classes of programs (simple, propositional/tight, disjunctive). The central finding is that rejection is inherently more complex than acceptance in abstract argumentation, with rejection problems reaching higher levels of the polynomial hierarchy. The paper also provides parameterized complexity results for the structural parameter treewidth, establishing matching upper and lower bounds.

## Method Summary
The authors analyze the computational complexity of decision and reasoning problems in abstract argumentation frameworks with rejection conditions. They consider various semantics (admissible, stable, complete, semi-stable, stage) and different classes of programs (simple, propositional/tight, disjunctive). The analysis uses standard complexity theory techniques including reductions, completeness proofs, and parameterized complexity analysis. For the treewidth analysis, they establish upper bounds through dynamic programming algorithms and lower bounds through reductions from known hard problems.

## Key Results
- Rejection problems are strictly harder than acceptance problems, ranging from Σ₂ to Σ₄ in the polynomial hierarchy
- For simple programs under admissible semantics, the problem is Σ₂-complete
- For propositional/tight programs under admissible semantics, the problem is Σ₃-complete
- For disjunctive programs under admissible semantics, the problem is Σ₄-complete
- Matching upper and lower bounds for treewidth parameterized complexity: tower(i,O(k))·poly(|A|) where i depends on the program class and k is the treewidth

## Why This Works (Mechanism)
The increased complexity of rejection problems stems from the additional layer of reasoning required to determine when arguments should be rejected based on the associated logic programs. Unlike acceptance conditions, which only need to verify if an argument is attacked, rejection conditions require evaluating the truth of complex logical formulas that depend on the entire argumentation framework. This creates dependencies that propagate through the framework in ways that make the problems inherently harder, pushing them to higher levels of the polynomial hierarchy.

## Foundational Learning
- **Abstract Argumentation Frameworks**: Need to understand the basic structure of argumentation frameworks (arguments and attacks) and various semantics (admissible, stable, complete, etc.). Quick check: Can you define what an admissible set is in an argumentation framework?
- **Logic Programming**: Understanding how logic programs can be used to specify conditions for rejection, including simple, propositional/tight, and disjunctive programs. Quick check: What's the difference between a simple program and a disjunctive program?
- **Complexity Theory**: Familiarity with polynomial hierarchy levels (Σ₂, Σ₃, Σ₄) and what completeness means at these levels. Quick check: What does it mean for a problem to be Σ₃-complete?
- **Parameterized Complexity**: Understanding treewidth as a structural parameter and tower functions. Quick check: What is the tower function and why is it relevant for treewidth parameterization?
- **Computational Complexity Classes**: Understanding the relationship between different complexity classes and how problems are classified. Quick check: How does Σ₂ differ from P or NP?
- **Reduction Techniques**: Understanding how problems can be reduced to each other to establish hardness results. Quick check: What is a polynomial-time reduction?

## Architecture Onboarding
- **Component Map**: Argumentation Framework (arguments + attacks) -> Logic Programs (rejection conditions) -> Semantics (admissible, stable, etc.) -> Decision Problems (existence, counting, etc.)
- **Critical Path**: The most computationally intensive path involves evaluating logic programs for rejection conditions, which depends on the entire argumentation framework and can lead to Σ₄ complexity
- **Design Tradeoffs**: The choice of program class (simple vs. disjunctive) directly impacts computational complexity, with more expressive programs leading to higher complexity
- **Failure Signatures**: Problems become intractable (Σ₂-Σ₄ complete) when rejection conditions involve complex logic programs, particularly disjunctive programs
- **First Experiments**:
  1. Implement a simple program checker for admissible semantics to verify Σ₂-completeness
  2. Build a dynamic programming algorithm for treewidth-based solving
  3. Create a reduction from a known Σ₃-complete problem to test the Σ₃-completeness of propositional/tight programs

## Open Questions the Paper Calls Out
None

## Limitations
- The theoretical hardness results (Σ₂-Σ₄ complete) may not directly translate to empirical difficulty for typical instances
- Treewidth-based algorithms have tower(i,O(k)) complexity, which may be impractical for large values of k
- The paper does not address potential approximation algorithms or heuristics for the intractable problems
- The interaction between rejection conditions and existing argumentation frameworks in practical scenarios could be explored further

## Confidence
- Theoretical Results: High - The proofs are mathematically rigorous and use standard complexity theory techniques
- Practical Applicability: Medium - Pending empirical validation of the treewidth-based algorithms on real-world argumentation frameworks
- Complexity Classification: High - The completeness proofs are well-established and follow standard methodology

## Next Checks
1. Empirical evaluation of the treewidth-based algorithms on real-world argumentation frameworks to assess practical performance
2. Investigation of approximation algorithms for the Σ₂-Σ₄ hard problems
3. Analysis of the interaction between rejection conditions and existing argumentation frameworks in practical scenarios