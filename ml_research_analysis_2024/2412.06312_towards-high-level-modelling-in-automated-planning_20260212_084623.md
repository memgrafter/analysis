---
ver: rpa2
title: Towards High-Level Modelling in Automated Planning
arxiv_id: '2412.06312'
source_url: https://arxiv.org/abs/2412.06312
tags:
- planning
- problem
- count
- robot
- pddl
- transformers
- self-attention
- retrieval-augmented-generation
- instruction-tuning
- parameter-efficient-finetuning
- mixture-of-experts
- chain-of-thought
core_contribution: "This paper introduces an extension of the UP Python library to\
  \ support high-level modelling in automated planning, addressing PDDL\u2019s limited\
  \ expressivity. Key additions include an array type, a count expression for Boolean\
  \ arguments, and integer parameters for actions, along with compilers to translate\
  \ these constructs into planner-compatible representations."
---

# Towards High-Level Modelling in Automated Planning

## Quick Facts
- arXiv ID: 2412.06312
- Source URL: https://arxiv.org/abs/2412.06312
- Reference count: 29
- Primary result: UP-extended models solve 216 Plotting instances vs 78 with PDDL, with reduced model size and improved clarity

## Executive Summary
This paper introduces an extension of the UP Python library to support high-level modelling in automated planning, addressing PDDL’s limited expressivity. Key additions include an array type, a count expression for Boolean arguments, and integer parameters for actions, along with compilers to translate these constructs into planner-compatible representations. The authors apply these features to model three classical planning problems—Plotting, Rush Hour, and 8-Puzzle—demonstrating more concise and natural problem encodings. Experimental results show the UP-extended model solves 216 Plotting instances versus 78 with PDDL, though solving times for Rush Hour and 8-Puzzle are comparable to PDDL. The approach reduces model size and improves clarity, with future work planned on additional high-level constructs and alternative encodings.

## Method Summary
The authors extended the UP library with three high-level features: array types for grid-based modelling, count expressions for Boolean argument counting, and integer parameters for actions. They developed corresponding compilers (ArrayRemover, IntegerParams, CountRemover) to translate these constructs into planner-compatible representations. The method was evaluated on three classical planning problems using Enhsp-opt and Fast-Downward planners with a 1-hour timeout, comparing solving performance and model size against PDDL models.

## Key Results
- UP-extended models solve 216 Plotting instances versus 78 with PDDL
- Solving times for Rush Hour and 8-Puzzle are comparable to PDDL models
- Model size is reduced and clarity improved compared to PDDL encodings

## Why This Works (Mechanism)

### Mechanism 1
- **Claim**: Adding array types to UP enables natural grid-based modelling, reducing the need for ad-hoc relational encodings.
- **Mechanism**: Arrays allow direct indexing into grid cells (e.g., `at_robot[r][c]`) instead of manually encoding adjacency or positional relationships. The Array Type Compiler translates these into individual Boolean fluents (`at_robot_r_c`) and decomposes compound assignments into conjunctive assignments, making the model planner-compatible.
- **Core assumption**: Planners can efficiently handle the expanded state space from flattened arrays without prohibitive blowup in grounding time.
- **Evidence anchors**:
  - [abstract] "experimental results show the UP-extended model solves 216 Plotting instances versus 78 with PDDL"
  - [section 4.1] "This type empowers us to represent tables or matrices effectively"
- **Break condition**: If the array size or dimensionality grows too large, grounding may explode combinatorially, overwhelming planner preprocessing.

### Mechanism 2
- **Claim**: Integer parameters in actions allow parameterized, compact action definitions that eliminate the need for enumerating all position-specific actions.
- **Mechanism**: Integer parameters (bounded) are passed to actions and later expanded by the Integer Parameters Compiler into a family of concrete actions, each with substituted values. This preserves high-level expressiveness while producing planner-friendly ground actions.
- **Core assumption**: The parameter bounds are small enough that the expansion does not generate an intractably large action set.
- **Evidence anchors**:
  - [section 4.2] "integers can be utilized not only for indexing arrays but also as values in preconditions or effects"
  - [section 4.4] "The required order, assuming all three implementations are included in a problem, is as follows"
- **Break condition**: If bounds are loose or symbolic reasoning is required, compilation may miss optimizations or generate redundant actions.

### Mechanism 3
- **Claim**: The Count expression compiler automates the translation of high-level Boolean counting into integer fluents and summation, enabling concise goal specifications.
- **Mechanism**: For each Count expression, the compiler generates integer fluents (`count_0`, `count_1`, ...) representing each Boolean argument. It replaces Count with Plus on these fluents, and adds conditional effects to update fluents when underlying Booleans change.
- **Core assumption**: The number of Count expressions and their arguments is manageable; otherwise, the number of generated integer fluents may become large.
- **Evidence anchors**:
  - [section 4.3] "The purpose of this function is to return an integer representing the number of True expressions among multiple Boolean expressions"
  - [section 5.1] "Our new implementation of the Count expression is particularly useful for this purpose as it facilitates the counting of blocks"
- **Break condition**: If Count expressions are nested or arguments are complex, the compiler may generate overly large expressions that planners cannot handle efficiently.

## Foundational Learning

- **Concept: High-level vs. Low-level planning representations**
  - Why needed here: The paper introduces high-level UP constructs (arrays, counts, integer parameters) that must be compiled down to low-level planner-compatible representations. Understanding this distinction is key to grasping the motivation and mechanism.
  - Quick check question: What is the difference between high-level and low-level representations in this paper, and why is compilation necessary?

- **Concept: Grounding in automated planning**
  - Why needed here: Grounding expands lifted actions and fluents into concrete propositional form. The paper’s compilation steps are essentially part of or alternatives to grounding, so understanding how grounding works is essential.
  - Quick check question: How does grounding transform a lifted planning problem into a ground one, and what role do the UP compilers play in this process?

- **Concept: Compiler ordering and dependency**
  - Why needed here: The paper specifies a strict order for applying compilers (Integer → Array → Count) to avoid undefined behavior. Knowing why this order matters prevents bugs.
  - Quick check question: Why must the Integer Parameters compiler be applied before the Array Type compiler, and what could go wrong if the order is violated?

## Architecture Onboarding

- **Component map**: UP Library (high-level API) -> Three Compilers (ArrayRemover, IntegerParams, CountRemover) -> Planner Interface (PDDL/ANML export)
- **Critical path**: Define problem → Apply compilers in order → Export to planner format → Solve with planner
- **Design tradeoffs**:
  - Expressive high-level constructs vs. planner compatibility
  - Compilation overhead vs. model conciseness
  - Permissive vs. restrictive undefinedness handling
- **Failure signatures**:
  - Out-of-bounds array access errors
  - Compiler order violations leading to missing or incorrect fluents
  - Integer parameter bounds too large, causing action explosion
  - Count expressions with too many arguments, causing planner overload
- **First 3 experiments**:
  1. Model a simple 3x3 grid robot delivery problem using arrays and integer parameters; verify compilation produces expected PDDL.
  2. Encode a Rush Hour instance; test permissive undefinedness handling for boundary moves.
  3. Implement a goal using Count to ensure exactly one robot in a room; confirm correct translation and planner compatibility.

## Open Questions the Paper Calls Out
None

## Limitations
- Improvements measured against only three classical planning problems
- UP library is still under development, affecting long-term stability and compatibility
- Evaluation uses only permissive undefinedness handling mode

## Confidence
- High confidence: The core mechanisms of array, count, and integer parameter extensions are clearly defined and demonstrated through examples.
- Medium confidence: The claim that UP-extended models reduce model size and improve clarity is supported by examples, but lacks quantitative comparisons across all three domains.
- Low confidence: The claim that solving times for Rush Hour and 8-Puzzle are "comparable" to PDDL is based on limited instances and requires broader validation.

## Next Checks
1. Test the UP-extended models on a larger and more diverse set of planning problems to verify scalability and robustness.
2. Compare solving times and memory usage across different undefinedness handling modes to assess trade-offs.
3. Validate the compilation order dependency by intentionally violating the sequence and documenting the resulting errors or inconsistencies.