---
ver: rpa2
title: Graph Pooling via Ricci Flow
arxiv_id: '2407.04236'
source_url: https://arxiv.org/abs/2407.04236
tags:
- graph
- pooling
- which
- curvature
- node
- transformers
- self-attention
- retrieval-augmented-generation
- instruction-tuning
- parameter-efficient-finetuning
- mixture-of-experts
- chain-of-thought
core_contribution: This paper introduces ORC-Pool, a graph pooling operator that combines
  Ollivier-Ricci curvature with node attributes to identify multi-scale structure
  in attributed graphs. Unlike existing curvature-based pooling methods, ORC-Pool
  evaluates both graph topology and node attributes by computing a curvature-adjusted
  adjacency matrix through Ricci flow, then applying a differentiable graph cut objective
  to determine cluster assignments.
---

# Graph Pooling via Ricci Flow

## Quick Facts
- arXiv ID: 2407.04236
- Source URL: https://arxiv.org/abs/2407.04236
- Authors: Amy Feng; Melanie Weber
- Reference count: 40
- Key outcome: ORC-Pool outperforms state-of-the-art pooling layers, achieving highest accuracy on all but one dataset

## Executive Summary
This paper introduces ORC-Pool, a novel graph pooling operator that combines Ollivier-Ricci curvature with node attributes to identify multi-scale structure in attributed graphs. The method uses Ricci flow to evolve edge weights based on curvature, then applies a differentiable graph cut objective to determine cluster assignments. Experiments on node clustering and graph classification tasks demonstrate superior performance compared to existing pooling methods while maintaining reasonable computational overhead.

## Method Summary
ORC-Pool integrates local and global geometric information by computing Ollivier-Ricci curvature and evolving edge weights using Ricci flow to create a curvature-adjusted adjacency matrix. It then applies a differentiable graph cut objective based on this matrix to compute cluster assignments that merge similar nodes while preserving distances between dissimilar nodes. The method can be integrated into GNNs as a pooling layer, preserving expressivity and mitigating oversmoothing. A combinatorial approximation provides scalability for large graphs.

## Key Results
- ORC-Pool achieves highest accuracy on all but one graph classification dataset tested
- Outperforms state-of-the-art pooling methods on node clustering tasks
- Runtime overhead is modest compared to traditional pooling layers
- Combinatorial approximation provides comparable accuracy with improved scalability

## Why This Works (Mechanism)

### Mechanism 1
- Claim: ORC-Pool integrates local and global geometric information to enhance graph pooling.
- Mechanism: ORC-Pool uses Ollivier-Ricci curvature and Ricci flow to adjust edge weights, emphasizing long-range connections and contracting edges between similar nodes, thereby revealing the coarse geometry of the graph.
- Core assumption: Edges between similar nodes have high curvature, while edges connecting dissimilar nodes have low curvature.
- Evidence anchors:
  - [abstract] "ORC-Pool extends such clustering approaches to attributed graphs, allowing for the integration of geometric coarsening into Graph Neural Networks as a pooling layer."
  - [section 2.2.1] "Edges that connect dissimilar nodes have low (usually negative) curvature, whereas edges that connect similar nodes have high curvature."

### Mechanism 2
- Claim: ORC-Pool mitigates oversmoothing by inducing scale separation.
- Mechanism: By merging similar nodes into supernodes and expanding distances between dissimilar nodes, ORC-Pool preserves local and global features separately, alleviating oversmoothing on coarser scales.
- Core assumption: Similar nodes tend to form densely connected subgraphs, and pooling layers induce scale separation.
- Evidence anchors:
  - [section 4.1] "By assigning higher weights to long-range connections and small weights to inter-community connections, distances between similar nodes are contracted and distances between dissimilar nodes are expanded."

### Mechanism 3
- Claim: ORC-Pool improves graph pooling performance by incorporating node attributes.
- Mechanism: ORC-Pool uses a differentiable graph cut objective based on the curvature-adjusted adjacency matrix to compute cluster assignments, allowing it to evaluate both graph topology and node attributes.
- Core assumption: Node attributes contain valuable information for downstream tasks, and their integration into the pooling process enhances performance.
- Evidence anchors:
  - [abstract] "ORC-Pool extends such clustering approaches to attributed graphs, allowing for the integration of geometric coarsening into Graph Neural Networks as a pooling layer."
  - [section 3.2] "ORC-Pool integrates both types of structural information to coarsen the graph."

## Foundational Learning

- Concept: Graph Neural Networks (GNNs) and Message-Passing GNNs (MPGNNs)
  - Why needed here: ORC-Pool is designed to be integrated into GNN architectures as a pooling layer, and understanding GNNs and MPGNNs is crucial for comprehending its functionality.
  - Quick check question: What is the difference between GNNs and MPGNNs, and how do they learn node representations?

- Concept: Graph Curvature and Ollivier-Ricci Curvature
  - Why needed here: ORC-Pool utilizes Ollivier-Ricci curvature to characterize the local geometry of a graph and identify multi-scale structure.
  - Quick check question: How does Ollivier-Ricci curvature relate to the local dispersion of geodesics and the local curvature of a manifold?

- Concept: Ricci Flow and its application in graph clustering
  - Why needed here: ORC-Pool employs Ricci flow to evolve edge weights and reveal the coarse geometry of the graph, which is essential for its clustering and pooling capabilities.
  - Quick check question: How does Ricci flow characterize graph geometry at a global scale, and how is it discretized for graphs?

## Architecture Onboarding

- Component map: Input Graph -> ORC-Pool Layer (Curvature Computation + Graph Cuts) -> Coarsened Graph
- Critical path:
  1. Compute Ollivier-Ricci curvature and evolve edge weights using Ricci flow
  2. Create curvature-adjusted adjacency matrix
  3. Perform graph cuts using differentiable objective based on curvature-adjusted adjacency matrix
  4. Coarsen the graph by merging nodes into supernodes
- Design tradeoffs:
  - ORC-Pool provides improved performance on attributed graphs but adds computational overhead compared to traditional pooling layers
  - The number of Ricci flow iterations is a crucial hyperparameter that impacts performance and runtime
- Failure signatures:
  - Poor performance on graphs without clear community structure
  - Increased runtime on large, dense graphs due to curvature computation
  - Degenerate clusters if the graph cut objective is not properly optimized
- First 3 experiments:
  1. Compare ORC-Pool with traditional pooling layers (e.g., MinCutPool) on a small attributed graph with known community structure
  2. Investigate the impact of varying the number of Ricci flow iterations on ORC-Pool performance and runtime
  3. Evaluate ORC-Pool's ability to mitigate oversmoothing by comparing node representations learned by a GNN with and without ORC-Pool layers on a deep architecture

## Open Questions the Paper Calls Out

- How does ORC-Pool's performance scale with graph size and density when using the combinatorial ORC approximation?
- Does ORC-Pool's curvature adjustment amplify over-squashing effects in deep GNNs?
- How sensitive is ORC-Pool to the choice of edge weight initialization when node attributes are present?
- Can ORC-Pool be effectively extended to directed graphs?

## Limitations
- Computational complexity of exact curvature computation limits applicability to large graphs
- Sensitivity to the number of Ricci flow iterations as a critical hyperparameter
- Lack of ablation studies isolating the contribution of curvature versus the graph cut objective

## Confidence
- High confidence: Basic curvature computation mechanism and its integration into GNN architectures
- Medium confidence: Performance claims across multiple datasets
- Low confidence: Scalability claims regarding the combinatorial approximation

## Next Checks
1. Implement and compare the exact versus combinatorial ORC approximation on graphs of increasing size to verify scalability claims and characterize the approximation error
2. Conduct controlled ablation experiments isolating the effects of curvature adjustment versus the differentiable graph cut objective on pooling performance
3. Test ORC-Pool on synthetic graphs with known community structure but varying levels of homophily to validate its effectiveness across different graph types