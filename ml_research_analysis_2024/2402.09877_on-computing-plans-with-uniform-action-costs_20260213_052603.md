---
ver: rpa2
title: On Computing Plans with Uniform Action Costs
arxiv_id: '2402.09877'
source_url: https://arxiv.org/abs/2402.09877
tags:
- plans
- action
- cost
- planning
- costs
- transformers
- self-attention
- retrieval-augmented-generation
- instruction-tuning
- parameter-efficient-finetuning
- mixture-of-experts
- chain-of-thought
core_contribution: The paper addresses the problem of finding plans with uniform action
  costs in automated planning. The core method idea involves adapting three dispersion
  metrics (number of different action costs, delta, and range) to automated planning
  and introducing planning-based compilations that allow lexicographic optimization
  of sum of action costs and action costs uniformity.
---

# On Computing Plans with Uniform Action Costs

## Quick Facts
- arXiv ID: 2402.09877
- Source URL: https://arxiv.org/abs/2402.09877
- Reference count: 6
- Primary result: Planning-based compilations enable lexicographic optimization of cost and uniformity for generating uniform action-cost plans

## Executive Summary
This paper addresses the challenge of finding plans with uniform action costs in automated planning. The authors adapt three dispersion metrics (number of different action costs, delta, and range) to automated planning and introduce planning-based compilations that allow lexicographic optimization of both sum of action costs and action costs uniformity. The approach reformulates planning tasks by adding propositions and actions that track cost distributions, enabling standard planners to optimize both objectives simultaneously.

## Method Summary
The core method involves extending standard planning tasks with new propositions that track action cost distributions, then adding action variants that update these counters while imposing additional costs when violating uniformity constraints. The compilation introduces propositions like `usedi`, `min costi`, `max costi`, and `check` to monitor cumulative properties of executed action costs. Three different dispersion metrics are supported: Number of Different Action Costs (simplest compilation with two action variants), Delta (tracks cost differences), and Range (tracks min/max costs). The method uses lexicographic optimization with a weight parameter ωd to enforce the priority between cost and uniformity objectives.

## Key Results
- The reformulated tasks can be effectively solved in practice to generate uniform plans
- Experimental results demonstrate that proposed compilations can generate plans that optimally balance cost and uniformity objectives
- The approach works across a large number of existing and novel planning tasks, showing good coverage and execution time performance

## Why This Works (Mechanism)

### Mechanism 1
- Reformulating the planning task to track action cost distributions via extra propositions and actions allows lexicographic optimization of cost and uniformity
- The compilation introduces propositions (e.g., `usedi`, `min costi`, `max costi`) that track cumulative properties of executed action costs
- New action variants update these counters and impose additional costs when violating uniformity constraints
- If action cost sets become large, the polynomial blowup in added actions and propositions becomes intractable

### Mechanism 2
- The number of different action costs metric is strictly isotonic, enabling a simpler compilation with only two action variants per original action
- For each action, one variant is used if its cost is already present, the other if not, with the latter adding a fixed penalty to discourage introducing new costs
- Strict isotony guarantees that the penalty scheme correctly enforces lexicographic preference without requiring tracking of the entire cost sequence
- If the smallest cost difference is zero (e.g., duplicate costs), the penalty structure may no longer distinguish plans by uniformity

### Mechanism 3
- Optimizing for Number of Different Action Costs implicitly approximates Range, Delta, and standard deviation well enough for practical purposes
- By minimizing the variety of action costs, plans naturally avoid large jumps (Delta) and wide spreads (Range)
- Uniformity in cost variety correlates strongly with other dispersion measures across typical planning domains
- In domains where plans with few distinct costs still have high Range or Delta (e.g., costs {1,2,100}), the implicit approximation breaks down

## Foundational Learning

- **Concept:** Dispersion metrics (Range, Delta, Number of Different Action Costs)
  - **Why needed here:** They quantify how uniform a plan's action costs are; selecting the right metric determines which uniformity property is optimized
  - **Quick check question:** Given a plan with costs [1,1,3,3], what are its Range, Delta, and Number of Different Action Costs?

- **Concept:** Lexicographic optimization
  - **Why needed here:** The goal is to optimize two objectives (cost and uniformity) in strict priority order, not as a weighted sum
  - **Quick check question:** If plan A has cost 10 and uniformity 2, and plan B has cost 12 and uniformity 1, which is preferred under lexicographic order (cost first)?

- **Concept:** Compilation-based reformulation of planning tasks
  - **Why needed here:** Transforms a multi-objective problem into a single-objective one by augmenting the state space and action set, enabling use of standard optimal planners
  - **Quick check question:** In the Number of Different Action Costs compilation, what extra propositions are added to the state?

## Architecture Onboarding

- **Component map:** Original planning task (F, A, I, G) -> Added propositions (`usedi`, `prev costi`, `deltai`, `max deltai`, `min costi`, `max costi`, `check`, `end`) -> Action variants (`Au`, `A¬u`, `Aδ`, `A∆`, `A¬∆`, `Aend`, `Aboth`, `Amin`, `Amax`, `Anone`) -> Compilation selector -> Planner wrapper

- **Critical path:**
  1. Parse and ground original PDDL task
  2. Detect action cost set `c(A)`
  3. Generate appropriate compilation (e.g., Π# for Number of Different Action Costs)
  4. Build new proposition and action sets according to metric semantics
  5. Set `ωd` to enforce lexicographic priority
  6. Invoke planner on compiled task
  7. Extract and post-process plan

- **Design tradeoffs:**
  - Simple compilation (Π#) → low overhead, good scalability, weaker uniformity guarantees
  - Complex compilations (Π∆, ΠR) → better uniformity control, higher state/action space growth
  - Integer-only costs → simpler compilation logic but may lose precision for real-valued costs
  - Fixed `ωd` scaling → ensures theoretical properties but may need tuning per domain

- **Failure signatures:**
  - Planner timeout or memory exhaustion → compilation generated too many actions/propositions
  - Coverage drop in Πd,c variants → difficulty in jointly optimizing cost and uniformity in reverse order
  - Dispersion suboptimality ratio >> 1 → compiled task not enforcing uniformity tightly enough

- **First 3 experiments:**
  1. Run standard planner on Π; record cost and uniformity metrics to establish baseline
  2. Compile to Π# with ωd=1, solve, and compare execution time overhead and uniformity vs baseline
  3. Compile to Π∆ with ωd=1, solve, and measure dispersion suboptimality ratio against optimal from Π#

## Open Questions the Paper Calls Out

### Open Question 1
- Question: How do the proposed compilations scale when applied to planning domains with significantly larger numbers of action costs, beyond the 101 different costs in the navigation domain?
- Basis in paper: [explicit] The authors note that domains like finance and navigation are particularly challenging due to their large number of different action costs, but evaluation focuses on 387 problems across 19 domains with max 101 different costs
- Why unresolved: The paper only tests up to 101 different action costs, and scalability with respect to the number of action costs is not systematically studied
- What evidence would resolve it: Systematic evaluation of compilations on domains with 500+, 1000+, or 10000+ different action costs, measuring both coverage and runtime, would establish scalability limits

### Open Question 2
- Question: Can the uniformity objective be effectively extended to other notions of uniformity beyond action cost uniformity, such as preferring to use the same grounded or lifted action repeatedly?
- Basis in paper: [explicit] The authors mention in the conclusion that extending compilations to other definitions of uniformity (e.g., preferring the same grounded or lifted action) is straightforward and they would like to evaluate these in future work
- Why unresolved: The paper only implements and evaluates cost-based uniformity metrics, leaving other notions of uniformity unexplored
- What evidence would resolve it: Implementation of compilations for action repetition uniformity and evaluation showing whether these generate plans that human users find more predictable or easier to execute

### Open Question 3
- Question: How does the choice between lexicographic optimization (cost first, then uniformity vs uniformity first, then cost) affect the practical usefulness of generated plans in real-world applications?
- Basis in paper: [explicit] The authors evaluate both ⪯c,d and ⪯d,c configurations but don't analyze which objective ordering produces more useful plans in different application domains
- Why unresolved: While the paper shows both configurations work, it doesn't investigate which ordering better serves specific real-world planning scenarios or user preferences
- What evidence would resolve it: User studies or domain-specific evaluations showing which objective ordering produces more acceptable or useful plans for specific applications like financial planning or navigation

## Limitations

- The experimental results show strong performance on standard benchmarks, but there is no validation on domains with non-uniform action cost distributions or where minimizing Range/Delta is critical
- The weight parameter ωd must be chosen carefully to preserve lexicographic optimization properties, but the paper does not provide guidance on how to set this parameter across different domains or cost scales
- While the compilations are proven polynomial in theory, the practical scalability to domains with large action cost sets or continuous costs is untested

## Confidence

- High confidence: The compilation mechanisms for tracking cost distributions are sound and the polynomial bounds are theoretically justified
- Medium confidence: The experimental results demonstrate effectiveness on standard benchmarks, but the generalization to diverse planning domains remains uncertain
- Low confidence: The claim that minimizing Number of Different Action Costs implicitly optimizes Range and Delta lacks direct empirical validation

## Next Checks

1. Test the compilations on domains with highly non-uniform action costs (e.g., {1, 2, 100}) to verify if minimizing Number of Different Action Costs still produces good Range and Delta values
2. Conduct ablation studies varying ωd across different cost scales to establish guidelines for parameter tuning
3. Apply the method to continuous-cost domains (e.g., robotics path planning with Euclidean distances) to assess practical scalability limits