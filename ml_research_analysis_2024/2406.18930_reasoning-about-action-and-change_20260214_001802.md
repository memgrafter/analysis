---
ver: rpa2
title: Reasoning About Action and Change
arxiv_id: '2406.18930'
source_url: https://arxiv.org/abs/2406.18930
tags:
- action
- state
- which
- update
- actions
- transformers
- self-attention
- retrieval-augmented-generation
- instruction-tuning
- parameter-efficient-finetuning
- mixture-of-experts
- chain-of-thought
core_contribution: This survey presents the state of research on formalizing reasoning
  about dynamic systems that can be partially observed and acted upon. The key concepts
  include system states, ontic and epistemic actions, and observations.
---

# Reasoning About Action and Change

## Quick Facts
- arXiv ID: 2406.18930
- Source URL: https://arxiv.org/abs/2406.18930
- Reference count: 14
- Primary result: Survey of formalizing reasoning about dynamic systems with partial observability and actions

## Executive Summary
This survey presents the state of research on formalizing reasoning about dynamic systems that can be partially observed and acted upon. The key concepts include system states, ontic and epistemic actions, and observations. Various reasoning processes are discussed, such as prediction, progression, regression, postdiction, filtering, abduction, and extrapolation. The paper highlights the importance of modeling both the system and the agent's beliefs, distinguishing between purely ontic and purely epistemic actions. It also addresses the frame and ramification problems in action representation, emphasizing the role of inertia and the need for formal languages like the situation calculus, STRIPS, dynamic logic, and dynamic Bayesian networks.

## Method Summary
This is a survey paper that synthesizes research on reasoning about action and change in dynamic systems. The paper reviews different formalisms and approaches for representing and reasoning about dynamic systems, including propositional action languages, situation calculus, dynamic logic, and Bayesian networks. It discusses various reasoning processes such as prediction, progression, regression, postdiction, filtering, abduction, and extrapolation. The survey also addresses the frame and ramification problems in action representation and the role of belief update in integrating action reasoning and belief change.

## Key Results
- Formalisms like situation calculus, STRIPS, and dynamic logic provide different approaches to reasoning about action and change
- The frame problem (what doesn't change) and ramification problem (indirect effects) are fundamental challenges in action representation
- Belief update operators face challenges in handling disjunctive effects and maintaining consistency with propositional fragments

## Why This Works (Mechanism)

### Mechanism 1
- Claim: Modeling actions as mappings between belief states enables formal reasoning about change.
- Mechanism: The paper introduces progression and regression as transformations on belief states using the function prog(b, α), where b is a belief state and α is an action. This allows reasoning about the effects of actions in a mathematically rigorous way.
- Core assumption: Belief states can be represented as probability distributions or sets of possible states, and actions can be modeled as transition systems.
- Evidence anchors:
  - [abstract] "The key concepts include system states, ontic and epistemic actions, and observations."
  - [section] "Progression (also called projection) consists in determining, according to one initial state of belief b and the description of a purely ontic action α, the new state of belief b′ resulting from the application of α in b."
  - [corpus] Weak - the corpus papers don't discuss formal belief state models directly.
- Break condition: If the system is not Markovian, the simple progression model breaks down and more complex representations are needed.

### Mechanism 2
- Claim: Successor State Axioms (SSAs) solve the frame problem by encoding what changes under an action.
- Mechanism: The paper describes Reiter's solution where each fluent P has an SSA: ∀s,x (P(do(x,s)) ↔ γP(x,s)), where γP specifies the conditions under which P is true after action x. This encodes inertia and only explicitly states what changes.
- Core assumption: Complete information about the conditions under which fluents change is available and expressible.
- Evidence anchors:
  - [section] "Reiter explains that using Successor States Axioms is a solution to the frame problem because one can reasonably expect the size of the set of SSA to be in the order of the number of fluents."
  - [section] "In order to decide whether the application of the action α in the state S0 leads to a state in which ψ holds, it is enough to decide if the formula φ(S0) → ψ(do(α,S0)) is valid."
  - [corpus] Weak - corpus papers don't discuss the frame problem or SSAs.
- Break condition: If the preconditions for action effects are incomplete or unknowable, SSAs cannot fully capture the necessary information.

### Mechanism 3
- Claim: Action languages provide compact, natural representations of actions and their effects.
- Mechanism: The paper presents STRIPS and other propositional action languages where actions are represented by preconditions and effects, avoiding the need to explicitly state what doesn't change (frame problem).
- Core assumption: Actions can be decomposed into local rules specifying only what changes, with default persistence of other fluents.
- Evidence anchors:
  - [section] "Action languages were built precisely to this aim: obtaining representations of the effects of the actions which are both more economic (or more compact) and more natural."
  - [section] "To encode the light switch example, one may take as set of fluents F = {Ua,Ub}, where Ua (resp. Ub) is true (resp. false) when switch a (resp. b) is on (resp. off)."
  - [corpus] Weak - corpus papers don't discuss action language design or compactness.
- Break condition: If actions have complex interdependencies or global effects, local rule representations may become insufficient or lead to incorrect inferences.

## Foundational Learning

- Concept: Discrete time modeling
  - Why needed here: The paper assumes discrete time steps (H = {0,...,N} or H = IN) to model the evolution of system states and the application of actions.
  - Quick check question: How would the reasoning processes change if time were continuous rather than discrete?

- Concept: Belief state representations
  - Why needed here: The paper uses two main uncertainty models - binary (sets of possible states) and Bayesian (probability distributions) - to represent an agent's beliefs about system states.
  - Quick check question: What are the computational tradeoffs between using a binary vs. Bayesian belief state representation?

- Concept: Frame and ramification problems
  - Why needed here: The paper discusses these classical action representation problems - the frame problem (what doesn't change) and the ramification problem (indirect effects) - and how different formalisms address them.
  - Quick check question: Why is it generally more efficient to encode what changes under an action rather than what doesn't change?

## Architecture Onboarding

- Component map: System states, ontic/epistemic actions, observations -> Belief representations (binary/Bayesian) -> Formalisms (situation calculus, STRIPS, dynamic logic, Bayesian networks) -> Reasoning processes (prediction, progression, regression, postdiction, filtering, abduction, extrapolation)
- Critical path: To reason about a dynamic system, an agent needs: (1) a state space and transition model, (2) a belief representation, (3) action representations, and (4) algorithms for reasoning processes like progression and regression.
- Design tradeoffs: More expressive action languages (like the situation calculus) allow for more nuanced reasoning but are harder to automate; simpler languages (like STRIPS) are easier to implement but less expressive.
- Failure signatures: Incorrect inferences about action effects, failure to handle non-deterministic or concurrent actions, inability to represent indirect effects (ramifications), or inefficient computation of reasoning processes.
- First 3 experiments:
  1. Implement progression for a simple STRIPS action in a binary belief state representation and verify it correctly computes the resulting state.
  2. Encode the light switch example in the situation calculus with successor state axioms and test regression on a formula.
  3. Compare the computational complexity of progression in STRIPS vs. the situation calculus for a small example domain.

## Open Questions the Paper Calls Out

### Open Question 1
- Question: How can belief update operators be effectively extended to handle disjunctive effects in action descriptions?
- Basis in paper: [explicit] The paper states that belief update operators based on minimization of change cannot handle disjunctions correctly, and that operators satisfying the Katsuno-Mendelzon postulates cannot handle disjunctions correctly.
- Why unresolved: The paper discusses the limitations of current approaches but does not provide a definitive solution for extending belief update operators to handle disjunctions.
- What evidence would resolve it: Development of a new belief update operator that can handle disjunctive effects while maintaining the desired properties of rationality postulates.

### Open Question 2
- Question: How can action description languages be unified to incorporate the expressiveness of both propositional action languages and update operators?
- Basis in paper: [explicit] The paper mentions that there are few attempts to unify the potentialities of various approaches, such as embedding Winslett's and Forbus' update operator and of Dalal's revision operator into dynamic logic.
- Why unresolved: The paper acknowledges the lack of unification but does not provide a comprehensive framework for integrating the expressiveness of different action description languages.
- What evidence would resolve it: Creation of a unified action description language that can express conditional effects, nondeterministic effects, concurrent effects, and static causal rules, while maintaining computational efficiency.

### Open Question 3
- Question: How can belief update operators be refined for propositional fragments to ensure the updated base belongs to the same fragment while approximating the behavior of the original operator?
- Basis in paper: [explicit] The paper discusses the problem of belief update operators not ensuring the updated base belongs to the same fragment, and mentions a constructive approach to refine update operators for propositional fragments.
- Why unresolved: The paper presents the issue but does not provide a detailed solution for refining belief update operators for propositional fragments.
- What evidence would resolve it: Development of a refined belief update operator for a specific propositional fragment that preserves tractability and approximates the behavior of the original operator.

## Limitations
- Limited empirical validation or implementation details provided for the theoretical frameworks
- Lack of comprehensive comparison of computational complexity between different formalisms
- Insufficient discussion of how theoretical frameworks handle real-world complexities like non-deterministic actions, concurrent actions, or incomplete information

## Confidence
- High confidence: The distinction between ontic and epistemic actions, and the basic characterization of reasoning processes (prediction, progression, regression) are well-established concepts in the literature.
- Medium confidence: The solutions to the frame and ramification problems (successor state axioms, action languages) are theoretically sound but their practical effectiveness depends heavily on the specific domain and implementation details not fully explored in the survey.
- Low confidence: The computational complexity claims and comparisons between different formalisms lack empirical support from the paper or corpus evidence.

## Next Checks
1. Implement a small domain (e.g., the light switch example) using both STRIPS and the situation calculus, then empirically compare the computational efficiency of progression in each formalism.
2. Test the successor state axioms approach on a domain with complex ramification chains to assess whether indirect effects are handled correctly.
3. Compare belief state update accuracy and computational cost between binary (set-based) and Bayesian (probability distribution) representations on a partially observable system with noisy observations.