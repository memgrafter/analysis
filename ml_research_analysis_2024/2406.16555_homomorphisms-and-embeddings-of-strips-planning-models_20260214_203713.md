---
ver: rpa2
title: Homomorphisms and Embeddings of STRIPS Planning Models
arxiv_id: '2406.16555'
source_url: https://arxiv.org/abs/2406.16555
tags:
- problem
- instance
- planning
- isomorphism
- have
- transformers
- self-attention
- retrieval-augmented-generation
- instruction-tuning
- parameter-efficient-finetuning
- mixture-of-experts
- chain-of-thought
core_contribution: The paper studies the complexity of finding isomorphisms and embeddings
  between STRIPS planning instances. It shows that determining whether two STRIPS
  instances are isomorphic is GI-complete and can be solved in quasi-polynomial time.
---

# Homomorphisms and Embeddings of STRIPS Planning Models

## Quick Facts
- arXiv ID: 2406.16555
- Source URL: https://arxiv.org/abs/2406.16555
- Authors: Arnaud Lequen; Martin C. Cooper; Frédéric Maris
- Reference count: 40
- Key outcome: Finding isomorphisms and embeddings between STRIPS planning instances is NP-complete, while isomorphism checking is GI-complete

## Executive Summary
This paper investigates the computational complexity of finding homomorphisms between STRIPS planning instances. It establishes that determining whether two STRIPS instances are isomorphic is GI-complete, making it theoretically solvable in quasi-polynomial time. The paper also proves that finding isomorphisms between a STRIPS instance and a subinstance of another, as well as finding embeddings, are both NP-complete problems. To address these challenges, the authors propose algorithms based on constraint propagation and SAT encoding, with extensive experimental results demonstrating significant performance improvements through preprocessing.

## Method Summary
The approach combines constraint propagation preprocessing with SAT encoding to find homomorphisms between STRIPS instances. The preprocessing phase uses an AC-3 adaptation to prune impossible mappings between fluents and operators based on the morphism property. The pruned problem is then encoded into propositional logic, with different encodings for different problem types (isomorphism, subinstance isomorphism, embedding). The resulting SAT formulas are solved using off-the-shelf SAT solvers, with the solutions providing valid homomorphisms when they exist.

## Key Results
- STRIPS isomorphism problem is GI-complete and can be solved in quasi-polynomial time
- Finding isomorphisms between a STRIPS instance and a subinstance is NP-complete
- Finding embeddings between STRIPS instances is NP-complete
- Constraint propagation preprocessing significantly improves SAT solver performance on benchmark problems

## Why This Works (Mechanism)

### Mechanism 1
- **Claim:** Mapping isomorphisms from STRIPS planning instances to graph isomorphism problems enables quasi-polynomial time solutions.
- **Mechanism:** By constructing finite models from STRIPS instances, the paper reduces the STRIPS isomorphism problem to a known GI-complete problem. This leverages the structural similarity between planning instances and finite models, where fluents, operators, and their relationships can be encoded as relations in a finite model.
- **Core assumption:** The isomorphism conditions between STRIPS instances can be faithfully translated into isomorphism conditions for finite models.
- **Evidence anchors:**
  - [abstract] "We show that the first is GI-complete, and can thus be solved, in theory, in quasi-polynomial time."
  - [section] "The proof follows a reduction from SI to the Finite Model isomorphism problem, as introduced in Definition 2."
  - [corpus] Weak: No direct mention of finite models or GI-completeness in neighbors.

### Mechanism 2
- **Claim:** Constraint propagation preprocessing significantly improves SAT solver performance by pruning impossible mappings early.
- **Mechanism:** The algorithm maintains domains for fluents and operators, iteratively revising them based on constraints derived from the morphism property. This reduces the search space before encoding to SAT, eliminating variables and clauses that cannot be part of a valid isomorphism.
- **Core assumption:** The constraints derived from the morphism property are sound and can be efficiently propagated to prune the search space.
- **Evidence anchors:**
  - [abstract] "We report extensive experimental trials on benchmark problems which demonstrate conclusively that applying constraint propagation in preprocessing can greatly improve the efficiency of a SAT solver."
  - [section] "Algorithmically, we enforce these constraints using an adaptation of AC3... The main loop... consists in revising all fluents and operators iteratively."
  - [corpus] Weak: No direct mention of constraint propagation in neighbors.

### Mechanism 3
- **Claim:** Embedding unsolvable instances into larger instances provides a proof of unsolvability for the larger instance.
- **Mechanism:** An embedding preserves the solvability properties of the embedded instance. If an unsolvable instance P' embeds into P, then P must also be unsolvable. This is because the embedding maps the state-space of P' onto a subset of P's state-space, preserving paths between states.
- **Core assumption:** The embedding conditions (Equations 19-23) correctly preserve the solvability properties of the embedded instance.
- **Evidence anchors:**
  - [abstract] "We also introduce the notion of embedding from an instance P to another instance P0, which allows us to deduce that P0 has no solution-plan if P is unsolvable."
  - [section] "Proposition 7. If P' embeds in P and P' has no solution-plan, then neither does P."
  - [corpus] Weak: No direct mention of embeddings or unsolvability proofs in neighbors.

## Foundational Learning

- **Concept:** Graph Isomorphism and GI-completeness
  - Why needed here: The paper leverages the GI-completeness of graph isomorphism to show that STRIPS isomorphism can be solved in quasi-polynomial time. Understanding GI-completeness is crucial for grasping the theoretical implications of the results.
  - Quick check question: What is the complexity class of the Graph Isomorphism problem, and why is it significant for this paper?

- **Concept:** Constraint Propagation (AC-3 algorithm)
  - Why needed here: The preprocessing step uses constraint propagation to prune impossible mappings before encoding to SAT. Understanding AC-3 is essential for implementing and debugging this part of the algorithm.
  - Quick check question: How does the AC-3 algorithm work, and what are its key components?

- **Concept:** SAT Encoding and Reduction
  - Why needed here: The paper reduces the STRIPS isomorphism and embedding problems to SAT, allowing the use of efficient SAT solvers. Understanding SAT encoding is crucial for implementing and optimizing this part of the algorithm.
  - Quick check question: How do you encode a constraint satisfaction problem into a propositional formula?

## Architecture Onboarding

- **Component map:** STRIPS instances -> Constraint propagation -> SAT encoding -> SAT solver -> Homomorphism
- **Critical path:** Parse STRIPS instances → Initialize domains → Constraint propagation → Encode to SAT → Solve with SAT solver → Interpret solution
- **Design tradeoffs:**
  - Using SAT solvers vs. direct CSP solving: SAT solvers are highly optimized but require encoding to propositional logic.
  - Constraint propagation overhead vs. search space reduction: Preprocessing adds overhead but can significantly reduce the size of the SAT problem.
  - Encoding efficiency: The size of the SAT encoding grows with the product of the sizes of the two instances, which can be a limiting factor.
- **Failure signatures:**
  - Preprocessing phase detects UNSAT early: Domains become empty during constraint propagation.
  - SAT solver returns UNSAT: No valid isomorphism/embedding exists.
  - SAT solver times out: Problem is too large or complex for the current approach.
- **First 3 experiments:**
  1. Test the preprocessing step on a simple STRIPS instance with known symmetries to verify that it correctly prunes impossible mappings.
  2. Encode a small STRIPS isomorphism problem to SAT and solve it with a SAT solver to verify the correctness of the encoding.
  3. Test the embedding detection on a pair of STRIPS instances where one is known to embed into the other to verify the correctness of the embedding algorithm.

## Open Questions the Paper Calls Out

### Open Question 1
- Question: What is the impact of allowing endomorphisms (as defined by Horčík and Fišer) instead of the stricter subinstance isomorphisms proposed in this paper?
- Basis in paper: [explicit] The paper mentions that Horčík and Fišer's endomorphisms only require pre(ν(o)) ⊆ υ(pre(o)) instead of equality, and do not require injectivity of the fluent mapping.
- Why unresolved: The paper does not explore the practical implications or trade-offs of using this weaker notion of homomorphism.
- What evidence would resolve it: An experimental comparison of planning efficiency when using endomorphisms vs. subinstance isomorphisms for various planning domains.

### Open Question 2
- Question: How can the pruning techniques be improved for domains with high symmetry?
- Basis in paper: [inferred] The paper notes that pruning is less effective in domains with high symmetry (e.g., Hanoi, TSP) and suggests exploring symmetry-breaking techniques.
- Why unresolved: The paper does not provide specific methods for leveraging symmetry in the pruning phase.
- What evidence would resolve it: A detailed analysis of symmetry patterns in planning domains and their incorporation into the constraint propagation algorithm.

### Open Question 3
- Question: What is the practical limit of the algorithm's applicability for very large planning instances?
- Basis in paper: [explicit] The paper reports solving instances up to 6368 fluents, but notes that the encoding size is O(|O|·|O'|·|F|·|F'|), suggesting scalability issues.
- Why unresolved: The paper does not explore the algorithm's performance beyond the reported benchmarks or investigate potential optimizations for large instances.
- What evidence would resolve it: A comprehensive study of the algorithm's scalability on synthetic and real-world planning instances of varying sizes and complexities.

## Limitations
- Experimental evaluation focuses on a narrow set of STRIPS benchmarks from a specific source
- Preprocessing benefits may not generalize to all planning domains with different characteristics
- The paper doesn't thoroughly explore cases where constraint propagation might be ineffective

## Confidence

- **High confidence:** The theoretical claims about GI-completeness and NP-completeness are supported by rigorous reductions
- **Medium confidence:** The practical effectiveness claims depend heavily on the specific benchmark set and solver used
- **Low confidence:** The embedding unsolvability proof mechanism is sound in theory but untested on real-world instances

## Next Checks

1. Test the constraint propagation preprocessing on a diverse set of planning benchmarks (including non-STRIPS domains) to assess generalizability of the performance benefits.

2. Evaluate the embedding detection approach on instances with known unsolvability properties to verify that it correctly identifies unsolvable cases through embedding.

3. Compare the proposed approach against specialized CSP solvers rather than just SAT solvers to determine if the encoding overhead is justified for different problem sizes.