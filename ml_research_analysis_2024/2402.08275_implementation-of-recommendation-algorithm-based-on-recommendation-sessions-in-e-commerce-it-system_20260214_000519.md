---
ver: rpa2
title: Implementation of Recommendation Algorithm based on Recommendation Sessions
  in E-commerce IT System
arxiv_id: '2402.08275'
source_url: https://arxiv.org/abs/2402.08275
tags:
- graph
- recommendation
- system
- objects
- algorithm
- transformers
- self-attention
- retrieval-augmented-generation
- instruction-tuning
- parameter-efficient-finetuning
- mixture-of-experts
- chain-of-thought
core_contribution: This paper describes implementation of the Algorithm of Recommendation
  Sessions (ARS) in a working e-commerce platform. The ARS algorithm models recommendation
  sessions as a bipartite directed graph, with nodes representing products and kernels
  (orders, visits, categories, etc.), and edges representing relationships.
---

# Implementation of Recommendation Algorithm based on Recommendation Sessions in E-commerce IT System

## Quick Facts
- arXiv ID: 2402.08275
- Source URL: https://arxiv.org/abs/2402.08275
- Reference count: 5
- Primary result: ARS algorithm implemented in SQL shows 3.2%-14.84% effectiveness with 0.56-0.97s recommendation generation time

## Executive Summary
This paper describes the implementation of the Algorithm of Recommendation Sessions (ARS) in a working e-commerce platform. The ARS algorithm models recommendation sessions as a bipartite directed graph, with nodes representing products and kernels (orders, visits, categories, etc.), and edges representing relationships. The graph is implemented in a relational database and the ARS algorithm is implemented using SQL queries. The system was deployed in a board game e-commerce site and demonstrated functional recommendation capabilities with measurable effectiveness metrics.

## Method Summary
The ARS algorithm was implemented using SQL standard queries on a relational database to model recommendation sessions as bipartite directed graphs. The graph structure consists of kernels (behavioral, static, mixed types) connected to products via directed edges. The implementation involves hourly graph reconstruction from source tables, SQL-based recommendation generation through subgraph analysis, and effectiveness tracking based on user selections. The system processes e-commerce data including products, orders, and user interactions to generate recommendations in 0.56-0.97 seconds.

## Key Results
- Graph grew from ~220k to ~370k elements over 17 days of operation
- Generated 4,926-9,813 recommendations per day
- Achieved 187-1,052 effective recommendations daily (3.2%-14.84% effectiveness)
- Recommendation generation time: 0.56-0.97 seconds
- Demonstrated fully functional recommendation system in production environment

## Why This Works (Mechanism)

### Mechanism 1
- Claim: The ARS algorithm effectively models recommendation sessions as bipartite directed graphs, enabling accurate product recommendations.
- Mechanism: By structuring data as kernels (orders, visits, categories) linked to products, the algorithm captures both user behavior and product relationships in a graph representation that can be queried efficiently.
- Core assumption: Each kernel type (behavioral, static, mixed) contributes meaningful signals for recommendation, and graph traversal reflects user intent.
- Evidence anchors:
  - [abstract] "A mathematical model of the recommendation session, constructed using graph and network theory, serves as the input for the ARS algorithm."
  - [section] "The solution proposes to build a data model based on the concept of the recommendation session... constructed using graph and network theory."
  - [corpus] Weak evidence; related papers focus on graph-based recommendation but don't specifically validate bipartite session graphs.
- Break condition: If kernel types become sparse or if product relationships don't reflect user intent, the graph structure loses predictive power.

### Mechanism 2
- Claim: Implementing the ARS algorithm using SQL standard queries in a relational database enables scalable, real-time recommendations.
- Mechanism: The graph is stored as edge lists in a relational table, and SQL queries efficiently compute recommendation vectors by traversing connected nodes and ranking by incoming degree.
- Core assumption: SQL execution time scales acceptably with graph size, and database indexing supports fast query performance.
- Evidence anchors:
  - [abstract] "The ARS algorithm is implemented using SQL queries... leading to the development of a fully functional recommendation system."
  - [section] "The implementation of the ARS algorithm was carried out... using the SQL standard implemented in the relational database."
  - [corpus] Limited direct evidence; related works mention graph databases but not SQL-based implementations for e-commerce.
- Break condition: Query performance degrades as graph grows beyond practical limits, or if database indexing is insufficient.

### Mechanism 3
- Claim: Effectiveness of recommendations is measurable by the ratio of effective recommendations to total recommendations.
- Mechanism: The system tracks user selections of recommended products and computes effectiveness as a percentage, providing a feedback loop for algorithm tuning.
- Core assumption: User clicks on recommended products are a valid proxy for recommendation quality, and the sample size is sufficient for statistical significance.
- Evidence anchors:
  - [abstract] "Over 17 days, the graph grew from ~220k to ~370k elements, with 4,926-9,813 recommendations per day, of which 187-1,052 were effective (3.2%-14.84% effectiveness)."
  - [section] "It has been called effectiveness and is calculated according to the formula: effectiveness = (number of effective recommendations / number of recommendations) * 100%."
  - [corpus] No direct evidence; effectiveness metrics vary across domains and no comparative benchmarks are provided.
- Break condition: If click-through rates are low due to presentation bias or if the definition of "effective" doesn't align with business goals.

## Foundational Learning

- Concept: Graph theory and bipartite directed graphs
  - Why needed here: The ARS algorithm relies on modeling recommendation sessions as bipartite directed graphs where kernels connect to products.
  - Quick check question: What distinguishes a bipartite graph from other graph types, and why is it suitable for modeling recommendation sessions?

- Concept: SQL query optimization and relational database design
  - Why needed here: The implementation stores the recommendation graph in a relational database and uses SQL queries to compute recommendations efficiently.
  - Quick check question: How does indexing on the kernel and object columns improve query performance for the ARS algorithm?

- Concept: Recommendation system evaluation metrics
  - Why needed here: The paper measures recommendation effectiveness using a specific metric (ratio of effective recommendations), which needs to be understood in context.
  - Quick check question: What are the limitations of using click-through rate as the sole measure of recommendation effectiveness?

## Architecture Onboarding

- Component map: `product -> graph_g (kernel-object edges) -> order_product, product_state`
- Critical path:
  1. Hourly graph rebuild from source tables
  2. Recommendation query execution for user session
  3. Effectiveness calculation and logging
- Design tradeoffs:
  - SQL vs. graph database: SQL offers compatibility but may limit complex traversals
  - Hourly vs. real-time graph updates: Balances freshness with computational cost
  - Effectiveness metric choice: Simple to compute but may not capture long-term value
- Failure signatures:
  - Slow query performance indicating graph growth issues
  - Low effectiveness rates suggesting poor recommendation relevance
  - Data inconsistency between source tables and graph representation
- First 3 experiments:
  1. Benchmark SQL query performance with varying graph sizes
  2. Compare effectiveness rates across different kernel types
  3. Test alternative effectiveness metrics (e.g., precision@k, recall)

## Open Questions the Paper Calls Out

### Open Question 1
- Question: How does the effectiveness of the ARS algorithm compare to other recommendation algorithms (e.g., collaborative filtering, content-based, or hybrid approaches) in the same e-commerce domain?
- Basis in paper: [explicit] The paper notes that the effectiveness of ARS (3.2%-14.84%) is not compared to other algorithms, and this is explicitly stated as a limitation.
- Why unresolved: The study only evaluates ARS in isolation and does not benchmark it against alternative recommendation methods, making it unclear whether ARS outperforms or underperforms existing approaches.
- What evidence would resolve it: Comparative experiments applying multiple recommendation algorithms (e.g., matrix factorization, deep learning-based CF, content-based) on the same dataset and evaluating their effectiveness, precision, recall, and user engagement metrics.

### Open Question 2
- Question: How does the addition of arc weights (Modification 1) impact the quality and effectiveness of recommendations in the ARS algorithm?
- Basis in paper: [inferred] The paper proposes assigning weights to arcs based on kernel classes (e.g., purchases vs. visits) but does not implement or evaluate this modification.
- Why unresolved: The theoretical benefit of weighting arcs is suggested but not empirically tested, so its actual impact on recommendation quality remains unknown.
- What evidence would resolve it: An implementation of ARS with weighted arcs, followed by A/B testing or offline evaluation comparing recommendation effectiveness (e.g., conversion rates, click-through rates) with and without weights.

### Open Question 3
- Question: Does incorporating user path history (Modification 2) improve recommendation relevance compared to the original ARS algorithm?
- Basis in paper: [inferred] The paper proposes storing user navigation history in set M to eliminate ARS's historical agnosticism but does not test this modification.
- Why unresolved: The potential improvement from considering user paths is hypothesized but not validated, leaving uncertainty about its practical benefit.
- What evidence would resolve it: A controlled experiment where ARS is modified to use user path history, with evaluation of recommendation accuracy (e.g., NDCG, MAP) and user satisfaction compared to the baseline ARS.

### Open Question 4
- Question: How does the scalability of ARS perform as the graph G grows significantly larger (e.g., 10x or 100x the current size)?
- Basis in paper: [explicit] The paper observes that recommendation generation time increases with graph size (0.56s to 0.97s over 17 days) and hypothesizes a relationship, but does not test extreme scaling scenarios.
- Why unresolved: The current results only cover moderate growth; long-term scalability under much larger graphs is untested, raising concerns about performance limits.
- What evidence would resolve it: Stress testing ARS on progressively larger synthetic or real-world graphs (e.g., 1M+ nodes) while measuring recommendation generation time, memory usage, and system throughput.

## Limitations
- The paper lacks detailed SQL query specifications and graph schema, making exact reproduction challenging
- Effectiveness metric relies solely on click-through rates without addressing presentation bias or long-term user value
- No comparative analysis against baseline recommendation algorithms or industry standards

## Confidence

- **High confidence**: The basic mechanism of using bipartite graphs for session-based recommendations is well-established in the literature
- **Medium confidence**: The SQL implementation approach is feasible based on the described architecture, though query specifics are missing
- **Low confidence**: The claimed effectiveness rates (3.2%-14.84%) lack context and comparative benchmarks

## Next Checks
1. Benchmark the SQL query performance against graph database alternatives for varying recommendation graph sizes
2. Conduct A/B testing comparing ARS effectiveness against traditional collaborative filtering approaches
3. Implement alternative effectiveness metrics (precision@k, recall, NDCG) to validate the click-through rate findings