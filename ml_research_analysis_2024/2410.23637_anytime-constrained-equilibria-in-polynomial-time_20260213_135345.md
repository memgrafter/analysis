---
ver: rpa2
title: Anytime-Constrained Equilibria in Polynomial Time
arxiv_id: '2410.23637'
source_url: https://arxiv.org/abs/2410.23637
tags:
- feasible
- policy
- then
- cost
- algorithm
- transformers
- self-attention
- retrieval-augmented-generation
- instruction-tuning
- parameter-efficient-finetuning
- mixture-of-experts
- chain-of-thought
core_contribution: 'This paper extends anytime constraints to Markov games, introducing
  the solution concept of an anytime-constrained equilibrium (ACE). It provides three
  main results: (1) a computational characterization of feasible policies using a
  directed graph and AND/OR tree approach, (2) a fixed-parameter tractable algorithm
  for computing subgame-perfect ACE, and (3) a polynomial-time algorithm for approximately
  computing ACE.'
---

# Anytime-Constrained Equilibria in Polynomial Time

## Quick Facts
- arXiv ID: 2410.23637
- Source URL: https://arxiv.org/abs/2410.23637
- Authors: Jeremy McMahan
- Reference count: 40
- Primary result: NP-hardness of feasible policy computation, but FPT and approximation algorithms exist

## Executive Summary
This paper introduces anytime-constrained equilibria (ACE) as an extension of anytime constraints from single-agent MDPs to multi-agent Markov games. The work provides a computational characterization of feasible policies using graph algorithms, proves that computing feasible policies is NP-hard even for simple games, and develops both fixed-parameter tractable algorithms for exact computation and polynomial-time approximation algorithms. The key insight is reducing the anytime-constrained problem to an action-constrained Markov game, enabling the use of standard equilibrium computation techniques.

## Method Summary
The approach reduces the anytime-constrained Markov game to an action-constrained Markov game by tracking cumulative costs and constructing feasible sets using a directed graph and AND/OR tree. The reduction preserves equilibrium properties, allowing standard solvers to be applied. For exact computation, the method uses a fixed-parameter tractable algorithm whose complexity depends on cost precision. For efficient approximation, it employs cost rounding and truncation to create a finite-support game that can be solved in polynomial time when the cost supremum is polynomially bounded relative to the budget.

## Key Results
- Computing feasible policies in anytime-constrained games is NP-hard even for two-player zero-sum games
- A fixed-parameter tractable algorithm computes subgame-perfect ACE in polynomial time when cost precision is logarithmic
- A polynomial-time approximation algorithm computes ε-approximate ACE when maximum supported cost is polynomially bounded by the budget
- The computational characterization uses AND/OR trees to determine feasibility in O(|S||A||H||B|) time

## Why This Works (Mechanism)

### Mechanism 1
- Claim: The reduction from anytime-constrained games to action-constrained Markov games preserves equilibrium properties.
- Mechanism: The anytime constraint on full histories is translated into a per-time constraint on available actions by tracking cumulative costs. This converts the original game into an action-constrained Markov game where the state space is defined by feasible (state, cumulative cost) pairs.
- Core assumption: The translation of policies between the original and reduced games preserves their equilibrium properties.
- Evidence anchors:
  - [abstract]: "We show that the subgame-perfect ACE of a cMG corresponds to the Markov-perfect equilibria of an action-constrained MG."
  - [section 4]: "Lemma 3(Equilibria). Any MPE (NE/CE/CCE) for G are ACSPE (NE/CE/CCE) for G."
  - [corpus]: Weak evidence - related works focus on different equilibrium concepts (Nash, correlated) rather than anytime-constrained equilibria.
- Break condition: If the action sets in the reduced game don't properly capture the anytime constraints, the equilibrium properties won't be preserved.

### Mechanism 2
- Claim: The fixed-parameter tractable algorithm runs in polynomial time when cost precision is logarithmic.
- Mechanism: The algorithm's complexity depends on the number of distinct cumulative cost vectors that can be realized, which is bounded by poly(|G|) * 2^(dn) where d is the cost precision and n is the number of players.
- Core assumption: The cost precision d remains small enough that the algorithm remains tractable.
- Evidence anchors:
  - [abstract]: "Our FPT algorithm runs in polynomial time so long as the supported costs require small precision."
  - [section 5]: "Theorem 3 (FPT). Equipped with any polynomial-time LP solver and MGSol ve= Algorithm 3, Algorithm 2 is a fixed-parameter tractable algorithm for computing ACSPE (CE/CCE) in the cost-precision d."
  - [corpus]: Weak evidence - related works don't address the specific FPT complexity analysis for anytime-constrained games.
- Break condition: If cost precision d grows too large (e.g., super-logarithmic in |G|), the algorithm becomes exponential.

### Mechanism 3
- Claim: The approximation algorithm achieves polynomial runtime when the cost supremum is polynomially bounded relative to the budget.
- Mechanism: By rounding down costs to multiples of a parameter ℓ and truncating extreme values, the algorithm creates an approximate game with finite support that can be solved efficiently.
- Core assumption: The ratio between maximum supported cost and budget remains polynomially bounded.
- Evidence anchors:
  - [abstract]: "Our approximation algorithm runs in polynomial time so long as the maximum supported cost is bounded by a polynomial factor of the budget."
  - [section 6]: "Corollary 2 (Relative). For any ϵ > 0, if we define ℓ = ϵ|B|/H, then Algorithm 4 correctly outputs an ϵ-relative approximate ACSPE (CE/CCE) for any acMG. Moreover, if cmax ≤ poly(|G|)|B|, Algorithm 4 runs in time O(poly(|G|, 1/ϵ^n))."
  - [corpus]: Weak evidence - related works focus on different approximation techniques rather than anytime constraint approximation.
- Break condition: If the cost supremum exceeds a polynomial factor of the budget, the approximation algorithm becomes inefficient.

## Foundational Learning

- Concept: Markov Games
  - Why needed here: The paper extends anytime constraints from single-agent MDPs to multi-agent settings, requiring understanding of game-theoretic solution concepts in sequential decision-making.
  - Quick check question: What distinguishes a Markov game from a single-agent MDP in terms of solution concepts?

- Concept: Equilibrium Concepts
  - Why needed here: The paper introduces anytime-constrained equilibria (ACE) and proves existence and computability results, requiring understanding of Nash, correlated, and subgame-perfect equilibria.
  - Quick check question: How does an anytime-constrained subgame-perfect equilibrium differ from a standard subgame-perfect equilibrium?

- Concept: Computational Complexity
  - Why needed here: The paper establishes NP-hardness results and develops FPT algorithms, requiring understanding of complexity classes and parameterized complexity.
  - Quick check question: Why does the NP-hardness of finding feasible policies in simple games imply that approximation is necessary for efficient computation?

## Architecture Onboarding

- Component map:
  - Graph algorithm -> Reduction -> Solver -> Output
- Critical path: Graph algorithm → Reduction → Solver → Output
  The graph algorithm must succeed (feasible policies exist) before proceeding to reduction and solver stages.
- Design tradeoffs:
  - Exact vs. approximate solutions: Exact algorithms are FPT but may be exponential; approximation provides polynomial runtime at the cost of constraint relaxation
  - Precision vs. complexity: Higher cost precision enables more accurate solutions but increases computational complexity exponentially
  - Space vs. time: The algorithm requires tracking cumulative costs, trading space for computational efficiency
- Failure signatures:
  - "Infeasible" output from graph algorithm indicates no feasible policies exist
  - Exponential runtime growth indicates cost precision or cost-to-budget ratio is too large
  - Suboptimal solutions indicate approximation parameter settings are too aggressive
- First 3 experiments:
  1. Test on simple two-player zero-sum game with small state/action spaces and tight budgets to verify feasibility detection
  2. Test on game with varying cost precision to observe FPT behavior and exponential growth point
  3. Test approximation algorithm with different ℓ parameters on game with known optimal solution to measure tradeoff between accuracy and runtime

## Open Questions the Paper Calls Out

### Open Question 1
- Question: How does the anytime-constrained equilibrium solution generalize to infinite-horizon Markov games?
- Basis in paper: [explicit] The paper mentions this extension in Remark 1 but does not provide details
- Why unresolved: The paper focuses on finite-horizon games and only hints at the infinite case without developing the theory
- What evidence would resolve it: A formal definition of anytime constraints for infinite-horizon games and proof that the computational characterization results extend to this setting

### Open Question 2
- Question: What is the computational complexity of computing an anytime-constrained correlated equilibrium (ACCE) versus an anytime-constrained Nash equilibrium (ACNE)?
- Basis in paper: [explicit] The paper mentions ACCE in Remark 2 but only provides complexity results for ACNE
- Why unresolved: The paper develops algorithms for ACNE but does not analyze whether the complexity bounds differ for ACCE
- What evidence would resolve it: Complexity analysis showing whether ACCE can be computed more efficiently than ACNE, possibly through different LP formulations

### Open Question 3
- Question: Can the approximation guarantees be improved beyond the current polynomial factor bound on cost supremum?
- Basis in paper: [inferred] The paper states "our approximation guarantees are the best possible in the worst case" but doesn't explore whether this bound is tight for specific game classes
- Why unresolved: The hardness results establish a worst-case lower bound, but specific game structures might allow better approximations
- What evidence would resolve it: Identifying game classes where tighter approximation bounds are achievable, or proving that the polynomial factor is indeed optimal even for restricted classes

## Limitations
- NP-hardness of feasibility checking even in simple two-player zero-sum games limits efficient exact computation
- FPT algorithms require logarithmic cost precision, becoming exponential when precision grows
- Approximation guarantees require restrictive assumptions about cost-to-budget ratios

## Confidence
- Graph-based feasibility characterization: High
- Reduction from anytime-constrained to action-constrained games: High
- FPT algorithm complexity analysis: Medium
- Approximation guarantee tightness: Low

## Next Checks
1. **Empirical Scalability Testing**: Implement the algorithms on a suite of benchmark games with varying cost precision, budget constraints, and state/action spaces to empirically verify the claimed FPT behavior and identify the point where exponential growth becomes prohibitive.

2. **Approximation Quality Assessment**: Test the approximation algorithm on games with known optimal solutions to measure the actual constraint violation and solution quality as a function of the approximation parameter ℓ, comparing against the theoretical bounds.

3. **Robustness to Cost Distribution Assumptions**: Evaluate algorithm performance on games where the cost supremum is not polynomially bounded by the budget, measuring runtime degradation and solution quality to assess the practical relevance of the theoretical complexity bounds.