---
ver: rpa2
title: 'From Probability to Counterfactuals: the Increasing Complexity of Satisfiability
  in Pearl''s Causal Hierarchy'
arxiv_id: '2405.07373'
source_url: https://arxiv.org/abs/2405.07373
tags:
- variables
- which
- satis
- languages
- values
- transformers
- self-attention
- retrieval-augmented-generation
- instruction-tuning
- parameter-efficient-finetuning
- mixture-of-experts
- chain-of-thought
core_contribution: 'This work investigates the computational complexity of satisfiability
  problems across Pearl''s Causal Hierarchy (PCH), which formalizes probabilistic,
  interventional, and counterfactual reasoning. The key finding is that adding marginalization
  (via the summation operator) increases complexity from NP^PP to NEXP across the
  hierarchy levels: probabilistic (NP^PP-complete), interventional (PSPACE-complete),
  and counterfactual (NEXP-complete).'
---

# From Probability to Counterfactuals: the Increasing Complexity of Satisfiability in Pearl's Causal Hierarchy

## Quick Facts
- arXiv ID: 2405.07373
- Source URL: https://arxiv.org/abs/2405.07373
- Reference count: 40
- Primary result: Adding marginalization increases complexity from NP^PP to NEXP across PCH levels, with surprising uniformity at succ-∃R when full polynomial operations are allowed

## Executive Summary
This work establishes the computational complexity of satisfiability problems across Pearl's Causal Hierarchy (PCH) levels—probabilistic, interventional, and counterfactual reasoning—under different language variants. The key finding demonstrates that marginalization via the summation operator increases complexity from NP^PP-complete for probabilistic reasoning to PSPACE-complete for interventional reasoning to NEXP-complete for counterfactual reasoning. Surprisingly, when full polynomial operations are permitted, the complexity collapses to succ-∃R-complete across all levels, solving an open problem about the complexity of counterfactual reasoning.

## Method Summary
The paper defines formal languages for causal reasoning across PCH layers, incorporating basic terms, linear terms, and polynomial terms with and without summation operators for marginalization. It establishes complexity results through reductions from canonical problems in various complexity classes: #SAT for NP^PP-hardness, QBF for PSPACE-hardness, and NEXP-complete problems for counterfactual reasoning. Containment in appropriate complexity classes is shown through algorithmic constructions, with succ-∃R membership proven via simulation on real RAM machines. The analysis assumes discrete finite domains for endogenous variables while allowing exogenous variables to take values in any domain.

## Key Results
- Adding marginalization increases complexity: NP^PP-complete → PSPACE-complete → NEXP-complete across PCH layers
- Counterfactual reasoning with full polynomial operations is succ-∃R-complete, same as probabilistic and interventional levels
- Languages with addition and marginalization yield strictly increasing complexity across PCH layers
- The expressiveness hierarchy L1 ⊊ L2 ⊊ L3 manifests computationally as a complexity hierarchy when marginalization is allowed

## Why This Works (Mechanism)

### Mechanism 1
- Claim: Adding marginalization via summation operator increases complexity across PCH layers
- Mechanism: The summation operator enables encoding of counting problems (#SAT) which are PP-complete, transforming SAT into higher complexity classes
- Core assumption: Summation can express marginalization without exponential blowup in syntax
- Evidence anchors:
  - [abstract]: "adding marginalization (via the summation operator) increases complexity from NP^PP to NEXP"
  - [section]: "From basic terms, we build more complex linear terms... by using additions and polynomial terms"
  - [corpus]: Weak - corpus focuses on tractability gateways rather than summation operator effects
- Break condition: If summation operator cannot efficiently encode marginalization, complexity gains disappear

### Mechanism 2
- Claim: Counterfactual reasoning remains as hard as probabilistic reasoning when full polynomial operations are allowed
- Mechanism: The succ-∃R class captures the combined complexity of polynomial terms and marginalization across all PCH levels
- Core assumption: succ-∃R completeness transfers from probabilistic to counterfactual levels when polynomial operations are permitted
- Evidence anchors:
  - [abstract]: "for full polynomial languages... the counterfactual level's complexity remains the same as for probabilistic and interventional levels (succ-∃R-complete)"
  - [section]: "The complexity of counterfactual reasoning (for the most general queries) remains the same as for common probabilistic reasoning"
  - [corpus]: Weak - corpus discusses satisfiability complexity but not the succ-∃R uniformity result
- Break condition: If succ-∃R completeness proof fails for counterfactual case, complexity would increase

### Mechanism 3
- Claim: Each PCH layer has strictly increasing expressiveness that manifests as complexity hierarchy when marginalization is allowed
- Mechanism: Higher layers can express constraints that distinguish models indistinguishable in lower layers, and marginalization enables counting arguments that exploit this expressiveness
- Core assumption: The expressiveness hierarchy L1 ⊊ L2 ⊊ L3 holds and can be leveraged computationally
- Evidence anchors:
  - [abstract]: "languages allowing addition and marginalization... yield NP^PP, PSPACE-, and NEXP-complete satisfiability problems, depending on the level of the PCH"
  - [section]: "On the other hand, in the case of full languages... we show that the satisfiability for the counterfactual level remains the same as for the probabilistic and causal levels"
  - [corpus]: Weak - corpus focuses on tractability rather than expressiveness-driven complexity
- Break condition: If expressiveness hierarchy breaks down under marginalization, complexity hierarchy may not emerge

## Foundational Learning

- Concept: Pearl's Causal Hierarchy (PCH) layers and their expressiveness relationships
  - Why needed here: Understanding why complexity increases across layers requires grasping the semantic differences between probabilistic, interventional, and counterfactual reasoning
  - Quick check question: Can you explain why two models indistinguishable in L1 might be distinguishable in L2?

- Concept: Summation operator as marginalization tool in causal languages
  - Why needed here: The core technical innovation relies on understanding how summation encodes marginalization efficiently
  - Quick check question: How does ∑_x P(Y|X=x) differ semantically from a sum over probabilities without the operator?

- Concept: Complexity class relationships (NP^PP, PSPACE, NEXP, succ-∃R)
  - Why needed here: The paper's main results hinge on placing problems in the correct complexity classes
  - Quick check question: Why is NP^PP the natural class for probabilistic reasoning with marginalization?

## Architecture Onboarding

- Component map: Language definition module -> Semantics evaluator -> Complexity classifier -> Reduction engine

- Critical path:
  1. Parse input formula into abstract syntax tree
  2. Identify PCH layer and allowed operators
  3. Apply appropriate complexity proof technique (counting, QBF encoding, EPR encoding)
  4. Determine complexity class membership
  5. Verify completeness via hardness proof

- Design tradeoffs:
  - Full expressiveness vs tractability: Including multiplication and conditional probabilities makes problems succ-∃R-complete but potentially easier to encode
  - Summation vs explicit expansion: Summation keeps formulas compact but requires more sophisticated complexity analysis
  - Model representation: Explicit SCM representation vs implicit through constraints affects algorithm design

- Failure signatures:
  - NP^PP completeness claimed but proof relies on PP oracle that cannot be implemented
  - succ-∃R completeness proof fails for counterfactual case due to conditional probability handling
  - Complexity hierarchy claimed but reduction from lower to higher layer fails

- First 3 experiments:
  1. Implement the NP^PP-hardness reduction for SAT_base^<Σ>_L1 and verify on small instances
  2. Test the PSPACE-hardness reduction for SAT_base^<Σ>_L2 with simple QBF formulas
  3. Validate the succ-∃R membership proof for SAT_poly^<Σ>_L3 using real RAM simulation

## Open Questions the Paper Calls Out

### Open Question 1
- Question: Does the strictly increasing complexity pattern (NP^PP → PSPACE → NEXP) hold for more expressive operators beyond linear and polynomial terms, such as transcendental functions or higher-order derivatives?
- Basis in paper: [explicit] The paper establishes increasing complexity for linear and polynomial languages with marginalization, but leaves open the complexity for polynomial languages at the counterfactual level (solved as succ-∃R-complete) and does not explore more complex operators.
- Why unresolved: The paper focuses on basic arithmetic operators and summation, leaving the behavior of more complex mathematical operations unexplored in the PCH context.
- What evidence would resolve it: Complexity results showing whether transcendental functions or higher-order operators maintain the increasing pattern or create different complexity relationships across PCH levels.

### Open Question 2
- Question: What is the precise relationship between ∃R and NPPP, and does this affect the completeness results for probabilistic reasoning with marginalization?
- Basis in paper: [explicit] The paper notes that "The relationship between ∃R and NPPP is unknown" in equation (1) and establishes NPPP-completeness for probabilistic reasoning with summation.
- Why unresolved: The paper assumes proper inclusions in equation (1) but acknowledges this specific relationship remains unproven, potentially affecting the interpretation of complexity results.
- What evidence would resolve it: A proof establishing either NPPP ⊆ ∃R, ∃R ⊆ NPPP, or that they are incomparable classes would clarify the exact positioning of probabilistic reasoning complexity.

### Open Question 3
- Question: How does the complexity of satisfiability problems change when considering continuous or infinite domains for exogenous variables, rather than the discrete finite domains assumed in the paper?
- Basis in paper: [inferred] The paper assumes "domains of endogenous variables X are discrete and finite" and notes that "exogenous variable s U could take values in any domains, including inﬁnite and continuous ones," but reduces to discrete finite domains for analysis.
- Why unresolved: The complexity analysis is built on discrete finite domains, and the paper does not explore how continuous or infinite domains would affect the established complexity classes.
- What evidence would resolve it: Complexity proofs showing whether the established completeness results (NP^PP, PSPACE, NEXP, succ-∃R) hold, strengthen, or weaken when exogenous variables have continuous or infinite domains.

## Limitations
- succ-∃R complexity class definition relies on external references, creating uncertainty about implementation
- Expressiveness hierarchy assumptions not tested on edge cases where layers might collapse
- Summation operator's computational impact demonstrated through reductions but not empirically validated

## Confidence
- NP^PP/PSPACE/NEXP completeness results: High
- succ-∃R uniformity result: Medium
- Expressiveness hierarchy claims: Medium

## Next Checks
1. Implement and verify the NP^PP-hardness reduction from #SAT to SAT_base^<Σ>_L1 on small benchmark instances
2. Construct concrete examples showing two models indistinguishable in L1 but distinguishable in L2 to validate expressiveness claims
3. Test the succ-∃R membership algorithm on polynomial causal queries to confirm containment before attempting completeness proof