---
ver: rpa2
title: 'VerilogCoder: Autonomous Verilog Coding Agents with Graph-based Planning and
  Abstract Syntax Tree (AST)-based Waveform Tracing Tool'
arxiv_id: '2408.08927'
source_url: https://arxiv.org/abs/2408.08927
tags:
- state
- logic
- verilog
- begin
- next
- transformers
- self-attention
- retrieval-augmented-generation
- instruction-tuning
- parameter-efficient-finetuning
- mixture-of-experts
- chain-of-thought
core_contribution: VerilogCoder is an autonomous Verilog code generation system that
  combines multiple AI agents with domain-specific tools to achieve high-quality Verilog
  code with functional correctness. The system uses a Task and Circuit Relation Graph-based
  planner to decompose module specifications into detailed sub-tasks with relevant
  signal and transition information, and an AST-based waveform tracing tool to debug
  and fix functional errors.
---

# VerilogCoder: Autonomous Verilog Coding Agents with Graph-based Planning and Abstract Syntax Tree (AST)-based Waveform Tracing Tool

## Quick Facts
- arXiv ID: 2408.08927
- Source URL: https://arxiv.org/abs/2408.08927
- Reference count: 40
- Primary result: 94.2% syntactically and functionally correct Verilog code generation on VerilogEval-Human v2 benchmark

## Executive Summary
VerilogCoder is an autonomous Verilog code generation system that combines multiple AI agents with domain-specific tools to achieve high-quality Verilog code with functional correctness. The system uses a Task and Circuit Relation Graph-based planner to decompose module specifications into detailed sub-tasks with relevant signal and transition information, and an AST-based waveform tracing tool to debug and fix functional errors. The approach achieves 94.2% syntactically and functionally correct Verilog code generation on the VerilogEval-Human v2 benchmark, surpassing state-of-the-art methods by 33.9%.

## Method Summary
VerilogCoder employs a multi-agent system with specialized LLM agents working collaboratively through ReAct reasoning. The system features a Task and Circuit Relation Graph (TCRG) planner that constructs structured task decompositions enriched with circuit signals and transitions, and an Abstract Syntax Tree (AST)-based waveform tracing tool for targeted functional debugging. The agents interact with Verilog tools including syntax checkers, simulators, and the AST-WT tool to iteratively generate and refine Verilog code until achieving functional correctness.

## Key Results
- 94.2% syntactically and functionally correct Verilog code generation on VerilogEval-Human v2 benchmark
- 33.9% improvement over state-of-the-art methods
- 7.7% improvement from TCRG-based planner, 11.5% improvement from AST-based waveform tracing tool

## Why This Works (Mechanism)

### Mechanism 1
TCRG enables high-quality task decomposition by enriching sub-tasks with signal and transition details through structured graph relationships connecting abstract tasks to concrete hardware details.

### Mechanism 2
AST-based waveform tracing enables targeted functional debugging by back-tracing mismatched signals through AST relationships to identify root causes in predictable signal propagation patterns.

### Mechanism 3
Multi-agent collaboration with ReAct reasoning enables autonomous correction of syntax and functional errors through specialized agents interacting with domain-specific tools in iterative Thought-Action-Observation loops.

## Foundational Learning

- Concept: Hardware description languages and digital circuit design fundamentals
  - Why needed here: Verilog generation requires understanding of sequential/combinational logic, finite state machines, and signal propagation
  - Quick check question: What is the difference between blocking and non-blocking assignments in Verilog, and when should each be used?

- Concept: Abstract Syntax Trees and compiler theory
  - Why needed here: AST-based waveform tracing relies on understanding code structure and signal dependencies
  - Quick check question: How does an AST represent the hierarchical structure of Verilog code, and what information does it capture about signal assignments?

- Concept: Finite state machine design and implementation
  - Why needed here: Many Verilog generation tasks involve FSMs, requiring understanding of state encoding, transitions, and output logic
  - Quick check question: What are the differences between Moore and Mealy FSMs, and how does this affect Verilog implementation?

## Architecture Onboarding

- Component map: High-level planner → TCRG construction → Code agent → Debug agent → Verilog tools (syntax checker, simulator, AST-WT) → Testbench validation
- Critical path: TCRG-based task planning → Code generation → Syntax validation → Functional simulation → AST-WT debugging → Code correction → Validation
- Design tradeoffs: Multi-agent complexity vs. single-agent simplicity; AST depth vs. computational cost; specialized tools vs. general-purpose LLMs
- Failure signatures: Stuck in debugging loops (agents can't resolve errors), inconsistent plans (planner and verification disagree), tool integration failures (agents can't use tools effectively)
- First 3 experiments:
  1. Test TCRG planning on a simple FSM module with clear state transitions
  2. Verify AST-WT can trace through a basic combinational logic module
  3. Run end-to-end generation on a module with both combinational and sequential logic

## Open Questions the Paper Calls Out

### Open Question 1
What are the theoretical limits of TCRG-based planning for complex Verilog modules with numerous interconnected signals and state transitions? The paper states TCRG-based planning provides 7.7% improvement but doesn't explore scalability limits or diminishing returns with increasing module complexity.

### Open Question 2
How does the AST-based waveform tracing tool perform with deeply nested or highly interconnected Verilog code structures? The paper describes a 2-level trace depth in examples but doesn't discuss performance with deeper nesting or complex signal dependencies.

### Open Question 3
What is the impact of VerilogCoder's multi-agent architecture on debugging time and computational resources compared to single-agent approaches? The paper describes multiple specialized agents but doesn't provide metrics on execution time, memory usage, or computational efficiency.

## Limitations

- The 94.2% success rate lacks detailed breakdown of error types and failure modes
- TCRG construction relies heavily on LLM-based extraction without quantitative validation of retrieval quality
- AST-WT tool performance depends on back-tracing depth parameter without clear guidance on optimal configuration

## Confidence

- High: TCRG improves task decomposition quality over baseline planners
- Medium: AST-based waveform tracing effectively identifies functional bugs in most cases
- Low: The claimed 33.9% improvement over state-of-the-art is robust across different VerilogEval subsets

## Next Checks

1. Perform ablation study on TCRG planner with varying signal/transition extraction quality to determine robustness to incomplete module descriptions
2. Characterize AST-WT back-tracing depth requirements across different circuit complexity levels to establish performance bounds
3. Evaluate system performance on VerilogEval subsets grouped by module complexity to identify scaling limitations