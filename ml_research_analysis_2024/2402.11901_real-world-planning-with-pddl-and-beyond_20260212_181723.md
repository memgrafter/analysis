---
ver: rpa2
title: Real-World Planning with PDDL+ and Beyond
arxiv_id: '2402.11901'
source_url: https://arxiv.org/abs/2402.11901
tags:
- pddl
- planning
- precondition
- state
- planner
- transformers
- self-attention
- retrieval-augmented-generation
- instruction-tuning
- parameter-efficient-finetuning
- mixture-of-experts
- chain-of-thought
core_contribution: This paper presents Nyx, a novel PDDL+ planner designed for real-world
  applications requiring hybrid system modeling. Nyx emphasizes lightness, simplicity,
  and adaptability to enable straightforward customization beyond PDDL+.
---

# Real-World Planning with PDDL+ and Beyond

## Quick Facts
- arXiv ID: 2402.11901
- Source URL: https://arxiv.org/abs/2402.11901
- Reference count: 4
- Primary result: Nyx is a novel PDDL+ planner designed for real-world applications requiring hybrid system modeling, emphasizing lightness, simplicity, and adaptability

## Executive Summary
This paper presents Nyx, a novel PDDL+ planner designed for real-world applications requiring hybrid system modeling. Nyx emphasizes lightness, simplicity, and adaptability to enable straightforward customization beyond PDDL+. Key features include expression compilation for efficient evaluation of PDDL+ constructs, precondition tree structure to efficiently check happening applicability, support for anytime search and plan metrics, and extensions enabling advanced mathematical expressions and semantic attachments for integrating external functions.

## Method Summary
Nyx is a Python-based PDDL+ planner that uses planning via discretization to convert continuous system dynamics into discrete state transitions for search. The planner employs forward-chaining search algorithms (BFS, DFS, GBFS, A*) and includes features like expression compilation and precondition trees for efficiency. It supports anytime search to improve solution quality over time and provides extensions for advanced mathematical expressions and semantic attachments to integrate external functions and libraries.

## Key Results
- Successfully applied to model and solve realistic problems including automatic reconfiguration of a ship-board fuel system using a Functional Mock-up Unit
- Expression compilation bridges performance gap between Python-based planner and C/C++ alternatives
- Precondition tree structure enables efficient pruning of inapplicable actions during search

## Why This Works (Mechanism)

### Mechanism 1
- Claim: Nyx uses expression compilation to bridge performance gap between Python-based planner and C/C++ alternatives
- Mechanism: Nyx translates PDDL expressions to Python bytecode at runtime via JIT compilation, using compiled code for subsequent evaluations
- Core assumption: PDDL expression evaluation is the primary bottleneck in planning search performance
- Evidence anchors:
  - [abstract] "To bridge the performance gap between Nyx and other planners written in compiled languages, Nyx features expression compilation"
  - [section] "Nyx translates them to equivalent Python bytecode at runtime. This compilation step is transparent to users and is performed in a just-in-time (JIT) fashion as expressions are evaluated for the first time"
- Break condition: If expression compilation overhead exceeds benefit for simple domains, or if JIT mechanism fails to optimize complex expressions

### Mechanism 2
- Claim: Precondition tree structure enables efficient pruning of inapplicable actions during search
- Mechanism: Precondition tree organizes action preconditions hierarchically, allowing single falsified precondition to prune entire branches of actions
- Core assumption: Many actions share common preconditions, making tree structure more efficient than linear checking
- Evidence anchors:
  - [section] "Structuring the precondition checking as a tree traversal task allows for efficient pruning of actions which contain falsified preconditions"
  - [section] "A single falsified precondition can prune multiple actions from being unnecessarily checked for applicability"
- Break condition: If domains have low precondition sharing or simple precondition expressions, tree overhead may outweigh benefits

### Mechanism 3
- Claim: Semantic attachments enable Nyx to handle system dynamics beyond PDDL+ expressiveness limits
- Mechanism: Nyx delegates computation of complex system dynamics to external functions via Python interface, allowing integration of advanced libraries and simulators
- Core assumption: Some real-world system dynamics cannot be adequately modeled using basic arithmetic operations in PDDL+
- Evidence anchors:
  - [abstract] "extensions enabling advanced mathematical expressions and semantic attachments for integrating external functions"
  - [section] "Nyx is equipped to accommodate semantic attachments... which enables the integration of advanced methods and libraries which cannot be exploited otherwise"
- Break condition: If external function integration introduces unacceptable latency or synchronization issues during planning search

## Foundational Learning

- Concept: Hybrid automata and PDDL+ modeling
  - Why needed here: Nyx specifically targets PDDL+ domains which model hybrid systems combining discrete and continuous dynamics
  - Quick check question: What are the three main components of a hybrid automaton that PDDL+ captures?

- Concept: Planning via discretization
  - Why needed here: Nyx uses discretization to convert continuous system dynamics into discrete state transitions for search
  - Quick check question: How does Nyx handle continuous processes differently from discrete events during time advancement?

- Concept: Search algorithm heuristics
  - Why needed here: Nyx supports multiple search algorithms including A* and GBFS that require heuristic functions
  - Quick check question: What information must a heuristic function return for Nyx to use it in priority queue ordering?

## Architecture Onboarding

- Component map: Main planner class coordinates parsing, search, and simulation; Parser handles PDDL+ file processing; Planner implements search algorithms; Simulator executes plan; Expression compiler handles JIT compilation; Precondition tree manager organizes precondition checking
- Critical path: PDDL file → Parser → Grounded domain → Search initialization → State expansion → Goal check → Solution extraction
- Design tradeoffs: Python implementation prioritizes accessibility and extensibility over raw performance; discretization approach trades accuracy for decidability; precondition tree adds overhead but improves pruning efficiency
- Failure signatures: Poor exploration rates indicate inappropriate search algorithm or missing heuristics; compilation errors suggest malformed PDDL expressions; semantic attachment failures point to integration issues with external functions
- First 3 experiments:
  1. Run Nyx on simple STRIPS domain to verify basic functionality and explore performance baseline
  2. Enable precondition tree on domain with many shared preconditions to measure pruning effectiveness
  3. Implement custom heuristic for a sample domain and verify it improves search efficiency

## Open Questions the Paper Calls Out

### Open Question 1
- Question: How does the precondition tree approach compare to alternative data structures (e.g., tries, hash maps) for efficient precondition checking in PDDL+ planning?
- Basis in paper: [explicit] The paper introduces the precondition tree and compares its performance to linear precondition checking, showing significant speedups for domains with many events and complex numeric preconditions.
- Why unresolved: The paper only compares the precondition tree to linear precondition checking, not to other potential data structures that could also improve efficiency.
- What evidence would resolve it: Empirical comparison of the precondition tree against alternative data structures like tries, hash maps, or other indexing methods for precondition checking in various PDDL+ domains.

### Open Question 2
- Question: What is the impact of precondition ordering on the efficiency of the precondition tree, and can optimal ordering be determined automatically?
- Basis in paper: [explicit] The paper mentions that precondition tree efficiency is affected by precondition ordering and suggests future work on analyzing node ordering optimization.
- Why unresolved: The paper does not provide empirical analysis of how different precondition orderings affect tree performance or methods for automatically determining optimal orderings.
- What evidence would resolve it: Empirical studies showing how different precondition orderings impact search efficiency, and algorithms for automatically determining optimal precondition orderings for given domains.

### Open Question 3
- Question: How does Nyx's semantic attachment mechanism compare to alternative approaches for integrating external functions in planning systems?
- Basis in paper: [explicit] The paper presents Nyx's semantic attachment approach and provides real-world examples of its use, but doesn't compare it to alternative methods.
- Why unresolved: The paper doesn't benchmark Nyx's semantic attachments against other approaches for integrating external functions like Monte Carlo Tree Search, learning-based methods, or other planning systems with similar capabilities.
- What evidence would resolve it: Comparative studies of Nyx's semantic attachments versus alternative methods for integrating external functions, including performance benchmarks and case studies across different real-world applications.

## Limitations

- Limited evaluation on diverse PDDL+ domains, focusing on a small set of benchmark problems
- Performance comparisons lack statistical significance testing, making it difficult to assess meaningful differences
- Single real-world case study (ship fuel system) may not represent broader real-world applicability

## Confidence

- High confidence in core architectural claims: Detailed implementation descriptions and technically sound mechanisms
- Medium confidence in performance claims: Limited comparison set and absence of statistical analysis reduce confidence
- Medium confidence in applicability claims: Single complex case study demonstrates practical utility but lacks systematic validation

## Next Checks

1. Conduct statistical analysis of performance differences between Nyx and competing planners across multiple benchmark runs to determine if observed differences are significant rather than due to random variation.

2. Extend evaluation to additional PDDL+ domains from established benchmarks (IPC, International Planning Competition) to assess generalizability across different problem classes and complexity levels.

3. Perform ablation studies to quantify the individual contributions of expression compilation, precondition trees, and semantic attachments to overall planning performance and development efficiency.