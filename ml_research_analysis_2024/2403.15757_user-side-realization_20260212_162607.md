---
ver: rpa2
title: User-Side Realization
arxiv_id: '2403.15757'
source_url: https://arxiv.org/abs/2403.15757
tags:
- uni00000013
- systems
- recommender
- page
- uni00000003
- transformers
- self-attention
- retrieval-augmented-generation
- instruction-tuning
- parameter-efficient-finetuning
- mixture-of-experts
- chain-of-thought
core_contribution: User-side realization addresses the challenge that users are often
  dissatisfied with services but lack the means to resolve their dissatisfaction,
  as they cannot alter the source code or force the service provider to change. The
  core idea is to provide general algorithms that run on the user's side and solve
  common problems without requiring the service provider to change the service itself.
---

# User-Side Realization

## Quick Facts
- arXiv ID: 2403.15757
- Source URL: https://arxiv.org/abs/2403.15757
- Reference count: 0
- One-line primary result: General algorithms can solve common user problems without requiring service provider changes

## Executive Summary
User-side realization addresses the fundamental challenge that users often face dissatisfaction with services but lack the means to resolve it, as they cannot alter source code or force service providers to change. The thesis introduces a novel approach that provides general algorithms running on the user's side to solve common problems without requiring service provider changes. Through two general approaches - wrapper method (modifying input/output of official functionality) and reverse method (reverse engineering services to add features) - user-side realization enables end-users to fulfill their desires by themselves.

The research demonstrates that despite severe limitations (users cannot access internal data or modify algorithms), user-side algorithms can achieve comparable performance to provider-side algorithms. The thesis presents several practical applications including fair recommender systems, tailor-made search engines, and privacy-aware translators, all tested in real-world services. These algorithms are designed to be general, applicable to various services, and capable of striking excellent trade-offs between performance and practical constraints like communication efficiency.

## Method Summary
The thesis proposes two general approaches for user-side realization: the wrapper method and the reverse method. The wrapper method modifies the input or output of the official functionality, allowing users to add features without accessing internal algorithms. The reverse method reverse engineers the service by observing its behavior, creating a copied version with additional functionalities. These approaches work within the severe constraints that users cannot access internal data or modify algorithms, relying instead on limited information available through APIs and observable outputs. The algorithms are designed to be general enough to apply across different services while maintaining performance comparable to provider-side solutions.

## Key Results
- User-side algorithms achieve comparable performance to provider-side algorithms despite severe limitations
- Consul strikes an excellent trade-off between performance and communication efficiency for fair recommender systems
- CLEAR realizes real-time image-to-image search on Flickr without initial crawling or indexing
- PRISM successfully makes translators privacy-aware while maintaining translation quality

## Why This Works (Mechanism)

### Mechanism 1
- Claim: User-side realization enables end-users to enjoy features even when service providers ignore or refuse them.
- Mechanism: Provides general algorithms that run on the user's side and solve problems without requiring service provider changes.
- Core assumption: The service exposes sufficient API endpoints or interfaces that user-side algorithms can wrap or reverse engineer.
- Evidence anchors:
  - [abstract]: "User-side realization offers proactive solutions to this problem by providing general algorithms to deal with common problems on the user's side."
  - [section 1.1.1]: "User-side realization must be done with such limited access to resources."
- Break condition: When service APIs are completely closed or rate-limited beyond practical use.

### Mechanism 2
- Claim: Two general approaches - wrapper method and reverse method - can realize any desired functionality on the user's side.
- Mechanism: Wrapper method modifies input/output of official functionality; reverse method reverse engineers service to add features to copied service.
- Core assumption: Either the official functionality is accessible enough to wrap, or the service behavior is observable enough to reverse engineer.
- Evidence anchors:
  - [section 1.2]: "We propose two general approaches for user-side realization (Figure 1.1)."
  - [section 1.2.1]: "A wrapper method wraps the official functionality and adds features."
- Break condition: When service behavior is too complex to observe or reverse engineer, or when official functionality is completely inaccessible.

### Mechanism 3
- Claim: User-side algorithms can achieve comparable performance to provider-side algorithms despite severe limitations.
- Mechanism: Leverages existing service outputs (recommendations, search results) and applies principled algorithms that work with limited information.
- Core assumption: The limited information available to users (e.g., top-K recommendations) contains sufficient signal for effective algorithms.
- Evidence anchors:
  - [section 1.1]: "Nevertheless, user-side algorithms do their best with these constraints and sometimes achieve the same or almost the same performance compared to provider-side algorithms."
  - [chapter 2]: "PrivateRank and PrivateWalk solve this problem by utilizing the official recommender systems."
- Break condition: When limited information is too noisy or sparse to extract meaningful signals.

## Foundational Learning

- Concept: Multi-armed bandit formulation for information retrieval
  - Why needed here: Enables efficient exploration of external databases with limited queries
  - Quick check question: How does the exploration-exploitation tradeoff apply when we have billions of images but only hundreds of queries?

- Concept: Differential privacy
  - Why needed here: Provides formal guarantees that user-side privacy protection methods actually work
  - Quick check question: What's the difference between (ε,0)-differential privacy and (ε,δ)-differential privacy?

- Concept: Metric recovery from k-NN graphs
  - Why needed here: Shows that recommendation networks contain sufficient information to reconstruct user-side systems
  - Quick check question: Why can't we exactly recover original embeddings from unweighted k-NN graphs?

## Architecture Onboarding

- Component map: User interface -> Score function evaluation -> API interaction layer -> Result processing -> Display to user
- Critical path: User action → Score function evaluation → API query → Result processing → Display to user
- Design tradeoffs:
  - Performance vs. communication efficiency (exact search vs. approximate)
  - Privacy vs. accuracy (more protection reduces translation quality)
  - Generality vs. specificity (abstract algorithms vs. service-specific solutions)
- Failure signatures:
  - API rate limits exhausted (wrapper methods fail)
  - Service behavior changes break reverse engineering (reverse methods fail)
  - Score function evaluation too slow (real-time applications fail)
- First 3 experiments:
  1. Test wrapper method on a simple service with known API
  2. Test reverse method on a small recommendation network
  3. Measure privacy-accuracy tradeoff on a translation task

## Open Questions the Paper Calls Out

### Open Question 1
- Question: How can user-side realization be extended to offline services and embedded systems beyond web services?
- Basis in paper: [explicit] The paper mentions that "user-side realization can shine also in offline services and embedded systems" and "Low-layer systems such as operating systems and hardware drivers may be interesting subjects of user-side algorithms."
- Why unresolved: The paper primarily focuses on web services and does not provide specific examples or solutions for offline services and embedded systems.
- What evidence would resolve it: Concrete examples of user-side algorithms applied to offline services and embedded systems, along with case studies demonstrating their effectiveness and challenges.

### Open Question 2
- Question: What are the trade-offs between privacy and utility in user-side privacy protection for machine translation systems, and how can they be optimized?
- Basis in paper: [explicit] The paper discusses the trade-off between privacy-preserving score and quality score in PRISM, but does not provide a comprehensive analysis of the trade-offs or optimization strategies.
- Why unresolved: The paper focuses on proposing methods (PRISM-R and PRISM*) and an evaluation protocol, but does not delve into the optimization of the trade-off between privacy and utility.
- What evidence would resolve it: A thorough analysis of the trade-offs between privacy and utility in user-side privacy protection for machine translation systems, along with optimization strategies and experimental results demonstrating their effectiveness.

### Open Question 3
- Question: How can user-side realization algorithms be packaged as browser add-ons and libraries to reach a wider audience and facilitate further research?
- Basis in paper: [explicit] The paper mentions that "Packaging them as browser add-ons will make these algorithms reach other end-users and broaden the scope of users" and "Building useful libraries is also important for this goal."
- Why unresolved: The paper does not provide specific guidelines or best practices for packaging user-side realization algorithms as browser add-ons and libraries.
- What evidence would resolve it: A comprehensive guide on packaging user-side realization algorithms as browser add-ons and libraries, along with case studies demonstrating their adoption and impact on research and user engagement.

## Limitations

- Approach fundamentally depends on service providers maintaining stable APIs and not implementing anti-user-side realization countermeasures
- Privacy protection mechanisms like word translation dictionaries may degrade translation quality
- Reverse engineering complex recommendation algorithms may fail when they use sophisticated models that cannot be easily approximated from observable outputs

## Confidence

- **High confidence** in the general methodology and framework: The thesis clearly articulates the problem space and provides two well-defined approaches (wrapper and reverse methods) that logically follow from the constraints.
- **Medium confidence** in performance claims: While the thesis states that user-side algorithms achieve "same or almost the same performance," the comparison methodology and evaluation metrics are not fully specified, making it difficult to independently verify these claims.
- **Medium confidence** in generality: The approach appears general in principle, but the specific algorithms presented may be tailored to particular service types, and their applicability to other domains is not thoroughly demonstrated.

## Next Checks

1. **API Stability Test**: Implement the wrapper method on a real service and deliberately modify the service's API to simulate provider changes, measuring the algorithm's robustness and required adaptation time.
2. **Privacy-Performance Tradeoff Measurement**: Systematically vary the size and quality of the word translation dictionary in the privacy-aware translation algorithm, measuring both privacy guarantees (differential privacy parameters) and translation quality degradation.
3. **Reverse Engineering Accuracy**: Apply the reverse method to a known recommendation algorithm (e.g., matrix factorization) and measure how accurately the user-side algorithm can reconstruct the recommendation scores compared to the ground truth, varying the amount of observable information.