---
ver: rpa2
title: A Compositional Typed Semantics for Universal Dependencies
arxiv_id: '2403.01187'
source_url: https://arxiv.org/abs/2403.01187
tags:
- rrbracket
- type
- semantic
- logical
- noun
- transformers
- self-attention
- retrieval-augmented-generation
- instruction-tuning
- parameter-efficient-finetuning
- mixture-of-experts
- chain-of-thought
core_contribution: UD Type Calculus provides a compositional, typed semantic framework
  that derives logical forms from Universal Dependencies syntax. It assigns semantic
  types and denotations to both words and dependency relations, using typed lambda
  expressions to combine meanings via functional application.
---

# A Compositional Typed Semantics for Universal Dependencies

## Quick Facts
- arXiv ID: 2403.01187
- Source URL: https://arxiv.org/abs/2403.01187
- Authors: Laurestine Bradford; Timothy John O'Donnell; Siva Reddy
- Reference count: 15
- Primary result: UD Type Calculus derives logical forms from Universal Dependencies syntax, achieving comparable performance to baseline systems on cross-linguistic meaning bank evaluation

## Executive Summary
UD Type Calculus (UD-TC) provides a compositional, typed semantic framework that derives Discourse Representation Structures (DRS) from Universal Dependencies syntax. The system assigns semantic types and typed lambda denotations to both words and dependency relations, enabling meaning composition through functional application. UD-TC handles semantic ambiguity by computing all possible logical forms for sentences with multiple valid composition orders, capturing phenomena like quantifier scope without requiring disambiguation. Evaluated on German, English, Italian, and Dutch data from the Parallel Meaning Bank, UD-TC achieves best-case F1 scores ranging from 48.1 to 62.4, comparable to an existing baseline system.

## Method Summary
UD-TC is a compositional semantic framework that builds on Universal Dependencies syntax to produce logical forms in the form of Discourse Representation Structures. The system assigns semantic types to both words and dependency relations, where relation denotations are typed lambda functions that combine the denotations of their head and dependent arguments. Composition proceeds according to semantic types, which constrain valid composition orders. When multiple compositions are possible, UD-TC computes all resulting logical forms to capture semantic ambiguity. The framework is designed to be language-independent and handles a variety of linguistic constructions through its typed lambda expressions and compositional rules.

## Key Results
- UD-TC achieves best-case F1 scores of 53.8 (German), 62.4 (English), 52.7 (Italian), and 48.1 (Dutch) when discourse relations are ignored
- The system produces multiple logical forms per sentence, capturing quantifier scope ambiguity and relative clause interpretations
- UD-TC's performance is comparable to the UD-Boxer baseline system across all four evaluated languages

## Why This Works (Mechanism)

### Mechanism 1
- **Claim**: Assigning denotations to both words and dependency relations allows composition of phrase meanings without needing extra meaning constructors.
- **Mechanism**: Each dependency relation is given a typed lambda function that takes the denotations of its head and dependent as arguments and returns a combined denotation. This enables building phrase meanings directly through functional application.
- **Core assumption**: Dependency labels carry semantic content that can be expressed as functions; no need for separate meaning constructors to specify syntactic environments.
- **Evidence anchors**:
  - [abstract] "UD Type Calculus, a compositional, principled, and language-independent system of semantic types and logical forms for lexical items which builds on a widely-used language-general dependency syntax framework."
  - [section 3] "Relation denotations are two-place functions taking their head's and dependent's denotations as arguments and returning a denotation for the combined phrase."

### Mechanism 2
- **Claim**: Semantic types constrain composition order, enabling derivation of all sensible logical forms while ruling out impossible ones.
- **Mechanism**: Each word and relation is assigned a semantic type (e.g., (et), (esj(st))), where the input and output types specify what can be composed with what. This allows multiple valid compositions when semantically possible while preventing invalid ones.
- **Core assumption**: The semantic type system can capture the necessary constraints for valid composition without being overly restrictive.
- **Evidence anchors**:
  - [section 3] "Semantic types can rule out potential composition orders of relation denotations... UD-TC framework consists entirely of the rules outlined above, which form an interface between Universal Dependencies and the space of DRS logical forms."
  - [section 5.3] "Using these, we can determine all sensible composition orders, even when multiple orders are possible."

### Mechanism 3
- **Claim**: Computing multiple logical forms per sentence captures semantic ambiguity (like quantifier scope) without requiring disambiguation.
- **Mechanism**: When multiple composition orders are semantically valid (e.g., for sentences with multiple quantifiers), UD-TC computes all possible logical forms, capturing all readings.
- **Core assumption**: Deriving all possible logical forms is preferable to committing to one reading, especially when the correct reading depends on context not available to the parser.
- **Evidence anchors**:
  - [abstract] "The system derives multiple possible logical forms per sentence, capturing phenomena like quantifier scope and relative clause interpretation through flexible composition orders while maintaining argument role accuracy."
  - [section 3] "When multiple composition orders of relations are possible, we treat them all as possible outputs of the system, thereby sometimes deriving several logical forms for one Universal Dependencies tree."

## Foundational Learning

- **Concept: Dependency syntax and Universal Dependencies**
  - Why needed here: UD-TC is built on UD syntax, so understanding dependency relations, tree structures, and UD labels is essential for implementing the system.
  - Quick check question: What is the root relation in UD, and how does it differ from other dependency relations in terms of arity?

- **Concept: Discourse Representation Structures (DRS)**
  - Why needed here: UD-TC uses DRS as the target semantic representation, so understanding DRS boxes, referents, assertions, and discourse relations is necessary for working with denotations.
  - Quick check question: What is the difference between a referent introduced in the upper box and an assertion in the lower box of a DRS?

- **Concept: Typed lambda calculus**
  - Why needed here: UD-TC uses typed lambda expressions to represent denotations, so understanding lambda abstraction, application, and type systems is crucial for implementing the semantic framework.
  - Quick check question: What is the difference between an atomic type (e, s, t) and a composite type (xy) in UD-TC's type system?

## Architecture Onboarding

- **Component map**: Parser -> Lexicon lookup -> Composition engine -> Ambiguity handler -> Evaluator
- **Critical path**:
  1. Parse raw text to UD trees
  2. Look up word and relation denotations and types in lexicon
  3. Compose meanings according to semantic types
  4. Handle ambiguity by generating all possible logical forms
  5. Evaluate against gold standards
- **Design tradeoffs**:
  - Computing all possible logical forms captures ambiguity but can be computationally expensive for sentences with many possible compositions
  - Using a simple type system makes the framework more language-independent but may not capture all semantic nuances
  - Relying on UD syntax makes the framework cross-linguistic but requires handling UD-specific issues like null elements
- **Failure signatures**:
  - No output produced: Likely due to resource constraints (time limits) or inability to compose meanings according to semantic types
  - Incorrect logical forms: May be due to errors in the lexicon (wrong denotations or types) or the composition engine (incorrect application of relation denotations)
  - Missing discourse relations: UD-TC deliberately ignores some discourse relations, so this is expected behavior
- **First 3 experiments**:
  1. Test the composition engine on a simple sentence (e.g., "The cat slept") with known denotations and types to verify basic functionality
  2. Test the ambiguity handler on a sentence with multiple quantifier scope readings (e.g., "Every cat chased a mouse") to verify it generates all possible logical forms
  3. Test the system on a small subset of the PMB corpus to verify it produces comparable results to the baseline (UD-Boxer)

## Open Questions the Paper Calls Out

### Open Question 1
- Question: How does UD-TC handle ambiguous syntactic structures that could yield multiple logical forms, and what is the computational complexity of generating all possible forms?
- Basis in paper: [explicit] The paper mentions that UD-TC computes every possible logical form for each sentence, which can take a long time for sentences with many ambiguous relations, and that resource constraints led to restricting computation time for some data points.
- Why unresolved: The paper provides an example of the median number of logical forms computed (154) but does not discuss the computational complexity in detail or provide a comprehensive analysis of how the system handles particularly complex or ambiguous structures.
- What evidence would resolve it: A detailed analysis of the computational complexity of UD-TC's approach, including specific examples of sentences with high ambiguity and the corresponding computational time, as well as potential optimizations or limitations of the current system.

### Open Question 2
- Question: How does the UD-TC framework handle languages with different word order and grammatical structures, and what are the implications for cross-linguistic semantic parsing?
- Basis in paper: [explicit] The paper states that UD-TC is designed to be language-independent and can handle a variety of linguistic constructions and languages, but it does not provide specific examples or a comprehensive evaluation of its performance across different language families or grammatical structures.
- Why unresolved: The paper only evaluates UD-TC on a limited set of languages (English, German, Italian, and Dutch) and does not discuss the potential challenges or limitations of applying the framework to languages with significantly different word orders or grammatical structures.
- What evidence would resolve it: A thorough evaluation of UD-TC's performance on a diverse set of languages, including those with different word orders and grammatical structures, and an analysis of the specific challenges and adaptations required for each language family.

### Open Question 3
- Question: How does UD-TC compare to other semantic parsing approaches in terms of accuracy and coverage, and what are the trade-offs between using a compositional typed semantics and other methods?
- Basis in paper: [explicit] The paper compares UD-TC to UD-Boxer, showing comparable performance, but does not provide a comprehensive comparison with other semantic parsing approaches or discuss the trade-offs between different methods.
- Why unresolved: The paper focuses on the evaluation of UD-TC against a single baseline (UD-Boxer) and does not provide a broader perspective on how the approach compares to other semantic parsing methods in terms of accuracy, coverage, or computational efficiency.
- What evidence would resolve it: A comparative study of UD-TC against a range of semantic parsing approaches, including both rule-based and machine learning methods, evaluating their performance on the same dataset and discussing the trade-offs between different approaches in terms of accuracy, coverage, and computational efficiency.

## Limitations
- The system's reliance on Universal Dependencies may not cleanly handle certain constructions like control verbs or comparative structures
- Evaluation is limited to German, English, Italian, and Dutch, leaving questions about performance on typologically distant languages
- Deliberate exclusion of discourse relations limits coverage of phenomena like presupposition and discourse-level anaphora

## Confidence

**High Confidence**: The core compositional mechanism (Mechanism 1) - using typed lambda functions to combine word and relation denotations - is well-grounded in established semantic theory and directly implemented in the system. The evaluation methodology, comparing against a gold standard using Counter, is standard practice in semantic parsing.

**Medium Confidence**: The type system's ability to constrain composition order (Mechanism 2) while remaining language-independent is theoretically sound but may face challenges with language-specific constructions. The cross-linguistic performance numbers are promising but based on a limited set of languages.

**Medium Confidence**: The approach of computing all possible logical forms (Mechanism 3) is principled but may become computationally intractable for longer sentences with many quantifiers or embedded clauses. The evaluation doesn't address scalability concerns.

## Next Checks
1. Test the system on sentences with control verbs and comparative constructions to assess how well the UD-TC framework handles these constructions that may not map cleanly to the compositional framework.

2. Evaluate the system on a typologically diverse language (e.g., Japanese or Arabic) to assess the claim of language-independence and identify potential issues with languages that have significantly different syntactic properties from the evaluation languages.

3. Conduct a scalability analysis by measuring computation time and memory usage for sentences of increasing length and complexity, particularly those with multiple quantifiers or nested relative clauses, to determine when the approach of computing all possible logical forms becomes computationally intractable.