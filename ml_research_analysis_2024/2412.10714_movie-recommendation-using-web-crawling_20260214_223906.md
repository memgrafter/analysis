---
ver: rpa2
title: Movie Recommendation using Web Crawling
arxiv_id: '2412.10714'
source_url: https://arxiv.org/abs/2412.10714
tags:
- data
- movie
- recommendation
- movies
- systems
- transformers
- self-attention
- retrieval-augmented-generation
- instruction-tuning
- parameter-efficient-finetuning
- mixture-of-experts
- chain-of-thought
core_contribution: The study addresses the challenge of providing timely and relevant
  movie recommendations by integrating real-time web-crawled data with static datasets.
  The approach combines content-based, collaborative, and hybrid filtering techniques
  to enhance recommendation accuracy.
---

# Movie Recommendation using Web Crawling

## Quick Facts
- **arXiv ID:** 2412.10714
- **Source URL:** https://arxiv.org/abs/2412.10714
- **Reference count:** 25
- **Primary result:** Real-time web-crawled data combined with static datasets improves movie recommendation relevance and freshness.

## Executive Summary
This paper proposes a hybrid movie recommendation system that integrates real-time web-crawled data from sources like Rotten Tomatoes and IMDb with static datasets such as TMDB and MovieLens. By combining content-based, collaborative, and hybrid filtering techniques, the system delivers personalized and up-to-date movie suggestions that reflect current viewing trends. The approach leverages Python's BeautifulSoup and requests libraries for data extraction and uses SVD-based matrix factorization alongside cosine similarity for hybrid recommendation refinement.

## Method Summary
The method involves scraping real-time movie data (ratings, reviews, cast, genres) from Rotten Tomatoes and IMDb using BeautifulSoup and requests. This data is merged with the TMDB Movies Dataset 2023 and MovieLens 25M dataset. Three recommendation models are built: content-based filtering using cosine similarity on movie attributes, collaborative filtering via SVD matrix factorization, and a hybrid model combining both approaches. The hybrid model refines collaborative recommendations using content similarity to improve personalization and relevance.

## Key Results
- Integration of real-time web data with static datasets enhances recommendation relevance and alignment with current trends.
- Hybrid filtering combines collaborative and content-based strengths for improved personalization.
- Real-time data scraping enables the system to capture emerging trends and update recommendations dynamically.

## Why This Works (Mechanism)

### Mechanism 1
- Claim: Combining real-time web-crawled data with static datasets improves recommendation relevance.
- Mechanism: Web scraping extracts current movie data (ratings, reviews, cast) from Rotten Tomatoes and IMDb, then merges this with structured historical data from Kaggle TMDB. The hybrid model refines initial collaborative recommendations using this enriched dataset, ensuring both popularity and personalization are considered.
- Core assumption: Real-time data reflects current user interests and can meaningfully shift recommendation rankings.
- Evidence anchors:
  - [abstract] "real-time data from sources like Rotten Tomatoes and IMDb is scraped... enriching the dataset with current trends and user preferences"
  - [section] "We scrape the Rotten Tomatoes website to gather key information... additional data, such as cast and crew information, was also collected from IMDb"
  - [corpus] Weak. Related papers mention dynamic updates but not direct web scraping integration.
- Break condition: If target sites block scraping or API rate limits are exceeded, the system reverts to static-only data, reducing freshness.

### Mechanism 2
- Claim: Hybrid filtering combines collaborative and content-based strengths for better personalization.
- Mechanism: Collaborative filtering (matrix factorization via SVD) identifies latent user preferences from past interactions. Content-based filtering (cosine similarity on genre/director/cast vectors) ensures recommendations match movie attributes. The hybrid model applies content refinement to the collaborative list.
- Core assumption: User preferences are consistent enough for collaborative methods, yet diverse enough to benefit from attribute-based matching.
- Evidence anchors:
  - [abstract] "The hybrid model refines recommendations by combining user interaction data with contextual attributes like genre and director"
  - [section] "The hybrid model combines content-based and collaborative filtering to provide comprehensive recommendations"
  - [corpus] Missing. No corpus neighbors explicitly discuss hybrid filtering mechanics.
- Break condition: Sparse user interaction data undermines collaborative accuracy, making content-based portion dominant.

### Mechanism 3
- Claim: Real-time data integration keeps recommendations aligned with current viewing trends.
- Mechanism: Periodic web crawling updates the movie database with newly released titles and trending films. The recommendation pipeline re-ranks suggestions using fresh popularity metrics alongside user history.
- Core assumption: Newly released or trending movies significantly influence user choice in the short term.
- Evidence anchors:
  - [abstract] "incorporating dynamic data not only boosts user satisfaction but also aligns recommendations with current viewing trends"
  - [section] "By scraping real-time data from Rotten Tomatoes and IMDb, the system dynamically identified Oppenheimer as trending and updated its recommendations"
  - [corpus] Weak. Related works mention real-time updates but not scraping for movie recommendations.
- Break condition: If crawling fails to capture emerging trends, recommendations lag behind actual user interest shifts.

## Foundational Learning

- Concept: Web scraping fundamentals (requests, BeautifulSoup, handling dynamic content)
  - Why needed here: Enables collection of current movie metadata and reviews from public sites.
  - Quick check question: How would you extract the director's name from a JSON-LD script tag in IMDb's HTML?

- Concept: Matrix factorization for collaborative filtering (SVD, latent factors)
  - Why needed here: Decomposes user-item interaction matrix to uncover hidden preference patterns.
  - Quick check question: What is the shape of the user-item matrix if you have 1000 users and 2000 movies?

- Concept: Hybrid recommendation logic (combining collaborative and content-based scores)
  - Why needed here: Balances personalized interaction data with movie attribute similarity.
  - Quick check question: How would you blend a collaborative score of 0.8 and a content similarity score of 0.6 into a final score?

## Architecture Onboarding

- Component map:
  - Data Ingestion: Web scraper (BeautifulSoup + requests) → Raw HTML → Parsed movie metadata
  - Data Storage: PostgreSQL/SQLite for static TMDB + scraped metadata
  - Collaborative Engine: SVD-based matrix factorization model
  - Content Engine: TF-IDF + cosine similarity on genres/directors/cast
  - Hybrid Engine: Weighted combination of collaborative and content scores
  - API Layer: Flask/FastAPI serving recommendations to frontend

- Critical path:
  1. Scrape real-time data → Update database
  2. Re-train/re-fit collaborative model on updated data
  3. Generate candidate list via collaborative filtering
  4. Refine candidates with content similarity
  5. Serve final ranked list

- Design tradeoffs:
  - Scraping vs. API: Scraping is more flexible but fragile to site changes; APIs are stable but may have limits.
  - Offline vs. online learning: Offline updates ensure batch consistency; online learning allows immediate adaptation but is complex.
  - Hybrid weighting: Equal weights may dilute strengths; tuned weights risk overfitting to current data.

- Failure signatures:
  - Scraping failures → Stale data → Recommendations lag trends
  - SVD convergence issues → Poor collaborative accuracy → Over-reliance on content-only
  - Database inconsistency → Missing movie records → Recommendation gaps

- First 3 experiments:
  1. Scrape a single movie page and extract title, director, genre; verify parsing logic.
  2. Train SVD on MovieLens subset; evaluate RMSE on holdout set.
  3. Combine SVD top-10 list with content-based top-10 list; test hybrid ranking with a small user group.

## Open Questions the Paper Calls Out

### Open Question 1
- Question: How does the integration of real-time web-scraped data with static datasets quantitatively improve recommendation accuracy compared to using either data source alone?
- Basis in paper: [explicit] The paper claims that incorporating dynamic data boosts user satisfaction and aligns recommendations with current viewing trends, but does not provide quantitative comparisons.
- Why unresolved: The paper describes the methodology and potential benefits of combining real-time and static data but lacks empirical results showing the magnitude of improvement in recommendation accuracy.
- What evidence would resolve it: Conducting controlled experiments comparing recommendation accuracy (e.g., precision, recall, or RMSE) between systems using only static data, only real-time data, and the hybrid approach would provide quantitative evidence of improvement.

### Open Question 2
- Question: What is the impact of the frequency of web crawling on the relevance and timeliness of movie recommendations?
- Basis in paper: [inferred] The paper emphasizes the importance of real-time data for capturing current trends but does not discuss how often the data should be scraped or the effects of different frequencies.
- Why unresolved: Without specifying the optimal frequency for web crawling, it's unclear how to balance the freshness of recommendations with the computational costs and potential rate limits imposed by data sources.
- What evidence would resolve it: Performing experiments with varying web crawling frequencies (e.g., hourly, daily, weekly) and measuring the impact on recommendation relevance and system performance would clarify the optimal approach.

### Open Question 3
- Question: How does the hybrid model handle conflicts between content-based and collaborative filtering recommendations?
- Basis in paper: [explicit] The paper describes a hybrid model that combines content-based and collaborative filtering but does not explain how it resolves discrepancies between the two methods.
- Why unresolved: Understanding the conflict resolution strategy is crucial for ensuring that the hybrid model produces coherent and reliable recommendations, especially when the two filtering methods suggest different movies.
- What evidence would resolve it: Providing details on the weighting mechanism or decision rules used to integrate recommendations from both filtering methods would demonstrate how conflicts are managed.

### Open Question 4
- Question: What are the scalability challenges when expanding the system to include more data sources and larger datasets?
- Basis in paper: [inferred] The paper mentions future work involving expanding data sources and integrating multiple datasets but does not address potential scalability issues.
- Why unresolved: As the system grows to include more data sources and larger datasets, challenges such as increased computational load, storage requirements, and data integration complexity may arise, affecting performance and feasibility.
- What evidence would resolve it: Conducting scalability testing by incrementally increasing the number of data sources and dataset sizes, then measuring system performance metrics like processing time and resource usage, would identify scalability bottlenecks.

## Limitations

- Lack of quantitative evidence showing the improvement in recommendation accuracy from integrating real-time data with static datasets.
- Absence of detailed evaluation metrics or comparative benchmarks against existing recommendation systems.
- Reliance on web scraping introduces fragility due to potential changes in website structure or API access restrictions.

## Confidence

- Confidence in the core claim (that real-time data improves recommendation relevance): **Medium**
- Confidence in the hybrid filtering approach: **Medium**
- Confidence in the real-time data integration claim: **Low**

## Next Checks

1. Implement a controlled experiment scraping a small set of movie pages and verify that the extracted metadata (genre, director, cast) correctly integrates with the TMDB dataset schema.
2. Train and evaluate the SVD collaborative filtering model on a subset of MovieLens data, measuring RMSE and comparing to baseline performance metrics.
3. Conduct a user study or simulation comparing hybrid recommendations (SVD + content-based) against pure collaborative or content-based approaches, focusing on relevance and freshness.