---
ver: rpa2
title: LLM+Reasoning+Planning for Supporting Incomplete User Queries in Presence of
  APIs
arxiv_id: '2405.12433'
source_url: https://arxiv.org/abs/2405.12433
tags:
- goal
- type
- date
- queries
- report
- transformers
- self-attention
- retrieval-augmented-generation
- instruction-tuning
- parameter-efficient-finetuning
- mixture-of-experts
- chain-of-thought
core_contribution: The paper addresses the problem of supporting incomplete user queries
  in the presence of APIs. User queries are often incomplete, i.e., they may not contain
  all the information required by the APIs.
---

# LLM+Reasoning+Planning for Supporting Incomplete User Queries in Presence of APIs

## Quick Facts
- arXiv ID: 2405.12433
- Source URL: https://arxiv.org/abs/2405.12433
- Reference count: 23
- The approach achieves over 95% success rate in handling incomplete user queries through logical reasoning and classical AI planning.

## Executive Summary
This paper presents a novel approach to handling incomplete user queries in the presence of APIs by combining large language models (LLMs) with logical reasoning and classical AI planning. The system addresses the common problem where user queries lack necessary information required by APIs to execute successfully. By leveraging Answer Set Programming (ASP) and Planning Domain Definition Language (PDDL), the approach can identify missing information, gather it through a specialized API, and orchestrate the necessary API calls to fulfill user requests. The evaluation demonstrates significant improvements over pure LLM-based approaches, particularly for complex multi-goal queries requiring dataflow between multiple APIs.

## Method Summary
The proposed approach translates user queries into a structured representation through an intermediate ASP layer, then converts this to PDDL for classical AI planning. A special "get_info_api" is introduced to gather missing information from users when queries are incomplete. All APIs are modeled as PDDL actions with explicit dataflow support between them. The classical AI planner generates an orchestration of API calls, including any necessary information-gathering steps, to fulfill the user's query. This hybrid approach combines the natural language understanding capabilities of LLMs with the structured reasoning power of ASP and PDDL to handle both complete and incomplete queries effectively.

## Key Results
- Achieves over 95% success rate in most cases for handling incomplete user queries
- Significantly outperforms pure LLM-based approaches in query resolution
- Demonstrates effectiveness across both single-goal and multi-goal query scenarios
- Successfully handles dataflow requirements between multiple APIs

## Why This Works (Mechanism)
The approach works by leveraging the complementary strengths of different AI paradigms. LLMs excel at understanding natural language and extracting intent from user queries, while ASP provides logical reasoning capabilities to identify missing information and constraints. PDDL enables structured planning of API interactions with explicit dataflow modeling. The classical AI planner can generate optimal sequences of API calls, including conditional information-gathering steps, ensuring that all necessary data is collected before execution. This multi-layered approach addresses the limitations of using any single paradigm alone, particularly the brittleness of pure LLM-based approaches when dealing with incomplete information.

## Foundational Learning

**Answer Set Programming (ASP)**
- Why needed: Provides logical reasoning capabilities to identify missing information and constraints in user queries
- Quick check: Can the system correctly identify which parameters are missing from a given API call?

**Planning Domain Definition Language (PDDL)**
- Why needed: Enables structured representation of API interactions and dataflow for planning purposes
- Quick check: Does the PDDL model accurately capture dependencies between API parameters and return values?

**Classical AI Planning**
- Why needed: Generates optimal sequences of API calls, including conditional information-gathering steps
- Quick check: Can the planner find valid execution paths for complex multi-goal queries?

## Architecture Onboarding

**Component Map**
User Query -> LLM -> ASP Representation -> PDDL Translation -> Classical Planner -> API Orchestration -> Result

**Critical Path**
The critical path involves query understanding (LLM), missing information identification (ASP), plan generation (Classical Planner), and API execution. Any bottleneck in these components directly impacts overall system performance and latency.

**Design Tradeoffs**
The approach trades off computational overhead of planning against the reliability of query resolution. While classical planning introduces latency, it provides more deterministic and complete query handling compared to pure LLM approaches. The translation layers (ASP and PDDL) add complexity but enable structured reasoning that LLMs alone cannot provide reliably.

**Failure Signatures**
Common failure modes include: incorrect ASP translation leading to wrong missing information identification, PDDL modeling errors preventing valid plan generation, planner timeouts on complex queries, and API execution failures due to incorrect parameter handling. The system should log failures at each translation stage for debugging.

**First Experiments**
1. Test with simple single-API queries to validate basic translation and planning pipeline
2. Evaluate multi-API queries with explicit dataflow requirements to assess orchestration capabilities
3. Test incomplete queries requiring user interaction through get_info_api to verify information gathering

## Open Questions the Paper Calls Out
None

## Limitations
- The approach may struggle with highly ambiguous or conversational queries that don't translate well to structured representations
- Scalability concerns exist for handling large numbers of APIs or real-time user interactions
- The system's behavior with conflicting or ambiguous information gathered by get_info_api is not fully explored
- Computational overhead of the planning component in production scenarios is not thoroughly examined

## Confidence

**High**
- API Orchestration Framework: The approach demonstrates robust capabilities in orchestrating multiple API calls with dataflow

**Medium**
- Query-to-PDDL Translation: The translation process shows promise but may face challenges with natural language variations
- Performance Claims: Success rates are impressive but primarily validated on controlled benchmark datasets

**Low**
- Scalability Analysis: Limited examination of performance characteristics with large API ecosystems

## Next Checks

1. Test the approach with more complex query patterns including nested conditions, temporal constraints, and ambiguous natural language formulations to assess robustness beyond the current benchmark.

2. Conduct a scalability evaluation measuring planning time and memory usage as the number of APIs and their complexity increase, particularly focusing on real-time interaction scenarios.

3. Implement error handling mechanisms for get_info_api and evaluate the system's behavior when facing conflicting or incomplete information during the query resolution process.